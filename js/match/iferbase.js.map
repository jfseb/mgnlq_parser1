{"version":3,"sources":["/projects/nodejs/botbuilder/mgnlq_parser1/src//projects/nodejs/botbuilder/mgnlq_parser1/src/../src/match/iferbase.ts"],"names":[],"mappings":";;;AAIA,IAAkB,gBAIjB;AAJD,WAAkB,gBAAgB;IAChC,6DAAW,CAAA;IACX,uDAAI,CAAA;IACJ,yDAAK,CAAA;AACP,CAAC,EAJiB,gBAAgB,GAAhB,wBAAgB,KAAhB,wBAAgB,QAIjC;AAGY,QAAA,YAAY,GAAG,UAAU,CAAC;AAC1B,QAAA,UAAU,GAAG,QAAQ,CAAC;AACtB,QAAA,QAAQ,GAAG,MAAM,CAAC;AAGlB,QAAA,iBAAiB,GAAG,eAAe,CAAC;AACpC,QAAA,eAAe,GAAG,aAAa,CAAC;AAK5C,CAAC;AAQD,CAAC;AAaW,QAAA,cAAc,GAAG,CAAC,eAAe,EAAE,aAAa,EAAE,YAAY,EAAE,WAAW,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AAgD5G,CAAC;AAWG,CAAC;AAkCL,CAAC;AAIuB,CAAC;AAgBzB,CAAC;AAoCD,CAAC;AAaD,CAAC;AA4BF,IAAkB,cAGjB;AAHD,WAAkB,cAAc;IAC9B,2DAAQ,CAAA;IACR,mEAAY,CAAA;AACd,CAAC,EAHiB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAG/B","file":"iferbase.js","sourcesContent":["\r\n\r\nimport {IFModel  as IFModel} from 'mgnlq_model';\r\n\r\nexport const enum EnumResponseCode {\r\n  NOMATCH = 0,\r\n  EXEC,\r\n  QUERY\r\n}\r\n\r\n\r\nexport const CAT_CATEGORY = \"category\";\r\nexport const CAT_FILLER = \"filler\";\r\nexport const CAT_TOOL = \"tool\";\r\n\r\n\r\nexport const ERR_NO_KNOWN_WORD = \"NO_KNOWN_WORD\";\r\nexport const ERR_EMPTY_INPUT = \"EMPTY_INPUT\";\r\n\r\nexport interface IERError {\r\n  err_code : string,\r\n  text : string\r\n};\r\n\r\nexport interface IERErrorNO_KNOWN_WORD extends IERError{\r\n  context : {\r\n    token : string,\r\n    index: number,\r\n    tokens : string[]\r\n  }\r\n};\r\n\r\n\r\n\r\nexport interface IPromptDescription {\r\n  description: string,\r\n  type: string,\r\n  pattern: RegExp,\r\n  message: string,\r\n  default: string,\r\n  required: boolean\r\n}\r\n\r\nexport const aOperatorNames = [\"starting with\", \"ending with\", \"containing\", \"excluding\", \"having\", \"being\"];\r\nexport type OperatorName = \"starting with\" | \"ending with\" | \"containing\" | \"being\" | \"excluding\" | \"having\";\r\n\r\nexport interface IOperator {\r\n  operator : OperatorName,\r\n  code : string,\r\n  arity : number,\r\n  argcategory : [ string[] ]\r\n}\r\n\r\nexport type IRecord = { [key : string] : string\r\n};\r\n\r\n\r\nexport interface IWhatIsAnswer {\r\n  sentence: ISentence,\r\n  record : IRecord,\r\n  category : string,\r\n  result: string,\r\n  _ranking : number\r\n}\r\n\r\n\r\nexport interface IProcessedWhatIsAnswers extends IProcessed {\r\n  sentences? : ISentence[],\r\n  answers : IWhatIsAnswer[]\r\n}\r\n\r\n\r\n\r\nexport interface IProcessedWhatIsTupelAnswers extends IProcessed {\r\n  sentences? : ISentence[],\r\n  tupelanswers : Array<IWhatIsTupelAnswer>\r\n}\r\n\r\n\r\nexport interface IWhatIsTupelAnswer {\r\n  sentence: ISentence,\r\n  record : IRecord,\r\n  categories : string[],\r\n  result: string[],\r\n  _ranking : number\r\n}\r\n\r\n\r\nexport interface IMatchedSetRecord {\r\n  setId : string,\r\n  record : IRecord\r\n};\r\nexport type IMatchedSetRecords = IMatchedSetRecord[];\r\n/**\r\n * Map category -> value\r\n */\r\nexport type IMatchSet = { [key : string] : string};\r\n\r\n\r\nexport interface IToolSet {\r\n      set: string[],\r\n      response: string\r\n    };\r\n\r\n\r\nexport interface IToolMatchResult {\r\n  required: { [key: string]: IWord },\r\n  missing: { [key: string]: number },\r\n  optional?: { [key: string]: IWord },\r\n  spurious: { [key: string]: number },\r\n  toolmentioned: IWord[]\r\n}\r\n\r\nexport interface IPrompt {\r\n  text: string,\r\n  category: string\r\n}\r\n\r\n\r\nexport interface IWord {\r\n  string: string,\r\n  matchedString: string,\r\n  category: string,\r\n  _ranking?: number,\r\n  levenmatch?: number,\r\n  reinforce?: number,\r\n  bitindex? : number,\r\n  rule? : IFModel.mRule\r\n}\r\n\r\nexport type ISentence = Array<IWord>;\r\n\r\nexport type IRule = IFModel.IRule;\r\n\r\nexport interface IRange {\r\n  low: number, high: number,\r\n};\r\n\r\nexport interface IWordRange extends IRange\r\n{\r\n  rule? : IFModel.mRule };\r\n/**\r\n * A rule matching a single string\r\n */\r\n\r\n\r\nexport interface IWordRules {\r\n  rules : Array<IFModel.mRule>,\r\n  bitindex: number\r\n}\r\n\r\nexport interface SplitRules {\r\n  allRules: Array<IFModel.mRule>,\r\n  nonWordRules : Array<IFModel.mRule>,\r\n  wordMap: { [key : string] : IWordRules },\r\n  wordCache :  { [key: string]: Array<ICategorizedString> }\r\n};\r\n\r\nexport interface ICategorizedString {\r\n  string: string,\r\n  matchedString: string,\r\n  category: string,\r\n  breakdown?: Array<any>\r\n  score?: number,\r\n  _ranking?: number,\r\n  levenmatch?: number  // a distance ranking\r\n}\r\n\r\nexport interface ICategorizedStringRanged extends ICategorizedString{\r\n  string: string,\r\n  matchedString: string,\r\n  category: string,\r\n  breakdown?: Array<any>\r\n  /**\r\n   * Length of the entry (for skipping following words)\r\n   */\r\n  score?: number,\r\n  span? : number,\r\n  rule : IFModel.mRule,\r\n  _ranking?: number,\r\n  levenmatch?: number  // a distance ranking\r\n}\r\n\r\nexport interface IProcessed {\r\n  tokens : string[],\r\n  errors? : IERError[]\r\n}\r\n\r\nexport interface IProcessedSentences extends IProcessed {\r\n  tokens : string[],\r\n  //errors? : any,\r\n  sentences : ISentence[]\r\n};\r\n\r\nexport type ICategoryFilter = { [key: string]: boolean };\r\n\r\n\r\nexport type IDomainCategoryFilter = {\r\n  domains : string[],\r\n  categorySet : { [key: string]: boolean }\r\n}\r\n\r\n\r\nexport interface IProcessedExtractedCategories extends IProcessed {\r\n  categories : string[],\r\n};\r\n\r\n\r\n\r\nexport type context = { [key: string]: string };\r\n\r\n/**\r\n * Defines the interface for an analysis\r\n * reponse\r\n */\r\nexport interface IResponse {\r\n  rating: number,\r\n  type: EnumResponseCode,\r\n  query: string,\r\n  context: { [key: string]: string },\r\n  text: string,\r\n  action: IAction,\r\n  prompts: {\r\n    [key: string]: {\r\n      text: string,\r\n      /**\r\n       * Follows the features of NPM prompts\r\n       */\r\n      description: IPromptDescription\r\n    };\r\n  }\r\n}\r\n\r\nexport const enum EnumActionType {\r\n  STARTURL,\r\n  STARTCMDLINE\r\n}\r\n\r\nexport interface IAction {\r\n  data: any,\r\n  type: EnumActionType,\r\n  pattern: string,\r\n  concrete: string\r\n}\r\n\r\n\r\nexport interface ICategoryDesc {\r\n  name: string,\r\n  importance? : number,\r\n  description? : string,\r\n  iskey? : boolean\r\n  exactMatch: boolean,\r\n  synonyms? : string[];\r\n}\r\n\r\n"],"sourceRoot":"ABC"}