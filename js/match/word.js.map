{"version":3,"sources":["/projects/nodejs/botbuilder/mgnlq_parser1/src//projects/nodejs/botbuilder/mgnlq_parser1/src/../src/match/word.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;;AASH,6CAAsC;AAGtC,gCAAgC;AAEhC,IAAI,QAAQ,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;AAEhB,QAAA,QAAQ,GAAG;IACtB,YAAY,EAAI,UAAU;IAC1B,UAAU,EAAI,QAAQ;IACtB,YAAY,EAAG,UAAU;IACzB,UAAU,EAAG,QAAQ;IACrB,UAAU,EAAG,QAAQ;IACrB,QAAQ,EAAG,MAAM;IACjB,OAAO,EAAI,KAAK;IAChB,YAAY,EAAG,CAAC,QAAQ,CAAC;IACzB,QAAQ,EAAG,UAAS,SAAkB;QACpC,OAAO,SAAS,KAAK,gBAAQ,CAAC,UAAU,CAAC;IAC3C,CAAC;IACD,UAAU,EAAG,UAAS,SAAkB;QACtC,OAAO,SAAS,KAAK,gBAAQ,CAAC,YAAY,CAAC;IAC7C,CAAC;IACD,QAAQ,EAAE,UAAS,SAAkB;QACnC,OAAO,gBAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;IACvD,CAAC;CACF,CAAA;AAEY,QAAA,IAAI,GAAG;IAClB,QAAQ,EAAG,UAAS,IAAmB;QACrC,OAAO,IAAI,CAAC,QAAQ,KAAK,SAAS,IAAI,gBAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACzE,CAAC;IACD,UAAU,EAAG,UAAS,IAAmB;QACvC,OAAO,gBAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC5C,CAAC;IACD,QAAQ,EAAG,UAAS,IAAmB;QACrC,IAAG,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAClC,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,GAAG,CAAC,gBAAgB,CAAC;SACpD;QACD,OAAO,gBAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC1C,CAAC;CACF,CAAC;AAGW,QAAA,QAAQ,GAAG;IACtB,YAAY,EAAI,UAAU;IAC1B,UAAU,EAAI,QAAQ;IACtB,UAAU,EAAG,QAAQ;IACrB,YAAY,EAAE,UAAU;IACxB,QAAQ,EAAG,MAAM;IACjB,YAAY,EAAG,CAAC,QAAQ,CAAC;IACzB,QAAQ,EAAG,UAAS,SAAkB;QACpC,OAAO,SAAS,KAAK,gBAAQ,CAAC,UAAU,CAAC;IAC3C,CAAC;IACD,UAAU,EAAG,UAAS,SAAkB;QACtC,OAAO,SAAS,KAAK,gBAAQ,CAAC,YAAY,CAAC;IAC7C,CAAC;IACD,QAAQ,EAAE,UAAS,SAAkB;QACnC,OAAO,gBAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;IACvD,CAAC;IACD,kBAAkB,EAAE,UAAS,SAAkB;QAE7C,IAAI,SAAS,IAAI,gBAAQ,CAAC,YAAY;YACpC,OAAO,qBAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC;QACnC,IAAI,SAAS,IAAI,gBAAQ,CAAC,YAAY;YACpC,OAAO,qBAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC;QACnC,IAAI,SAAS,IAAI,gBAAQ,CAAC,UAAU;YAClC,OAAO,qBAAO,CAAC,QAAQ,CAAC,MAAM,CAAC;QACjC,IAAI,SAAS,IAAI,gBAAQ,CAAC,UAAU,EACpC;YACE,2DAA2D;YAC3D,OAAO,qBAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,OAAO;SAC5C;QACD,IAAI,SAAS,IAAI,gBAAQ,CAAC,UAAU;YAClC,OAAO,qBAAO,CAAC,QAAQ,CAAC,MAAM,CAAC;QACjC,IAAI,SAAS,IAAI,gBAAQ,CAAC,QAAQ;YAChC,OAAO,qBAAO,CAAC,QAAQ,CAAC,IAAI,CAAC;QAC/B,IAAK,SAAS,IAAI,gBAAQ,CAAC,OAAO;YAChC,OAAO,qBAAO,CAAC,QAAQ,CAAC,GAAG,CAAC;QAC9B,KAAK,CAAC,6BAA6B,GAAG,SAAS,CAAE,CAAC;QAClD,OAAO,SAAS,CAAC;IACnB,CAAC;CACF,CAAA","file":"word.js","sourcesContent":["/**\r\n * @file word\r\n * @module jfseb.fdevstart.sentence\r\n * @copyright (c) Gerd Forstmann\r\n *\r\n * Word specific qualifications,\r\n *\r\n * These functions expose parf the underlying model,\r\n * e.g.\r\n * Match a tool record on a sentence,\r\n *\r\n * This will unify matching required and optional category words\r\n * with the requirements of the tool.\r\n *\r\n */\r\n\r\n// <reference path=\"../../lib/node-4.d.ts\" />\r\n\r\n// import * as debug from 'debug';\r\n\r\n// import * as utils from '../utils/utils';\r\n\r\nimport * as IMatch from './iferbase';\r\nimport { IFModel } from 'mgnlq_model';\r\n\r\n\r\nimport * as debug from 'debugf';\r\n\r\nvar debuglog = debug('word');\r\n\r\nexport const Category = {\r\n  CAT_CATEGORY :  \"category\",\r\n  CAT_DOMAIN :  \"domain\",\r\n  CAT_OPERATOR : \"operator\",\r\n  CAT_FILLER : \"filler\",\r\n  CAT_NUMBER : \"number\",\r\n  CAT_TOOL : \"tool\",\r\n  CAT_ANY  : \"any\",\r\n  _aCatFillers : [\"filler\"],\r\n  isDomain : function(sCategory : string )  : boolean{\r\n    return sCategory === Category.CAT_DOMAIN;\r\n  },\r\n  isCategory : function(sCategory : string )  : boolean{\r\n    return sCategory === Category.CAT_CATEGORY;\r\n  },\r\n  isFiller: function(sCategory : string) : boolean {\r\n    return Category._aCatFillers.indexOf(sCategory) >= 0;\r\n  }\r\n}\r\n\r\nexport const Word = {\r\n  isFiller : function(word : IMatch.IWord) : boolean {\r\n    return word.category === undefined || Category.isFiller(word.category);\r\n  },\r\n  isCategory : function(word : IMatch.IWord) : boolean {\r\n    return Category.isCategory(word.category);\r\n  },\r\n  isDomain : function(word : IMatch.IWord) : boolean {\r\n    if(word.rule && word.rule.wordType) {\r\n      return word.rule.wordType === 'D' /* WORDTYPE_D */;\r\n    }\r\n    return Category.isDomain(word.category);\r\n  }\r\n};\r\n\r\n\r\nexport const WordType = {\r\n  CAT_CATEGORY :  \"category\",\r\n  CAT_DOMAIN :  \"domain\",\r\n  CAT_FILLER : \"filler\",\r\n  CAT_OPERATOR: \"operator\",\r\n  CAT_TOOL : \"tool\",\r\n  _aCatFillers : [\"filler\"],\r\n  isDomain : function(sCategory : string )  : boolean{\r\n    return sCategory === Category.CAT_DOMAIN;\r\n  },\r\n  isCategory : function(sCategory : string )  : boolean{\r\n    return sCategory === Category.CAT_CATEGORY;\r\n  },\r\n  isFiller: function(sCategory : string) : boolean {\r\n    return Category._aCatFillers.indexOf(sCategory) >= 0;\r\n  },\r\n  fromCategoryString: function(sCategory : string) : string\r\n  {\r\n    if( sCategory == Category.CAT_CATEGORY )\r\n      return IFModel.WORDTYPE.CATEGORY;\r\n    if( sCategory == Category.CAT_OPERATOR )\r\n      return IFModel.WORDTYPE.OPERATOR;\r\n    if( sCategory == Category.CAT_FILLER )\r\n      return IFModel.WORDTYPE.FILLER;\r\n    if( sCategory == Category.CAT_NUMBER )\r\n    {\r\n      //console.log(\"This is N? \" + IFModel.WORDTYPE.NUMERICARG);\r\n      return IFModel.WORDTYPE.NUMERICARG; // \"N\";\r\n    }\r\n    if( sCategory == Category.CAT_DOMAIN )\r\n      return IFModel.WORDTYPE.DOMAIN;\r\n    if( sCategory == Category.CAT_TOOL )\r\n      return IFModel.WORDTYPE.TOOL;\r\n    if ( sCategory == Category.CAT_ANY )\r\n      return IFModel.WORDTYPE.ANY;\r\n    debug(\" unable to map to category \" + sCategory );\r\n    return undefined;\r\n  }\r\n}\r\n"],"sourceRoot":"ABC"}