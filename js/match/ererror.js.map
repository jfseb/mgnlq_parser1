{"version":3,"sources":["../src/match/ererror.ts"],"names":[],"mappings":";AAAA;;;;;;;GAOG;;;AAKH,+BAA+B;AAE/B,MAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;AACjC,MAAM,SAAS,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;AAClC,MAAM,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;AAI9B,MAAM,SAAS,GAAQ,MAAM,CAAC;AAK9B,sDAAsD;AACtD,qCAAqC;AAErC,SAAgB,uBAAuB,CAAC,KAAc,EAAE,MAAiB;IACrE,IAAG,KAAK,GAAG,CAAC,IAAI,KAAK,IAAI,MAAM,CAAC,MAAM,EAAE;QACtC,MAAM,KAAK,CAAC,sCAAsC,GAAG,KAAK,GAAG,eAAe,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;KAC/F;IACH,OAAO;QACL,QAAQ,EAAE,MAAM,CAAC,iBAAiB;QAClC,IAAI,EAAG,wBAAwB,MAAM,CAAC,KAAK,CAAC,IAAI;QAChD,OAAO,EAAG;YACR,MAAM,EAAE,MAAM;YACd,KAAK,EAAG,MAAM,CAAC,KAAK,CAAC;YACrB,KAAK,EAAG,KAAK;SACd;KAC8B,CAAC;AACpC,CAAC;AAbD,0DAaC;AAGD,SAAgB,qBAAqB;IACnC,OAAO;QACL,QAAQ,EAAE,MAAM,CAAC,eAAe;QAChC,IAAI,EAAG,yBAAyB;KACd,CAAC;AACvB,CAAC;AALD,sDAKC;AAED,SAAgB,YAAY,CAAC,MAA0B;IACrD,IAAG,MAAM,CAAC,MAAM,EAAE;QAChB,OAAO,IAAI,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KACtD;IACD,OAAO;AACT,CAAC;AALD,oCAKC","file":"ererror.js","sourcesContent":["/**\r\n *\r\n * @module jfseb.fdevstart.analyze\r\n * @file erbase\r\n * @copyright (c) 2016 Gerd Forstmann\r\n *\r\n * Basic domain based entity recognition\r\n */\r\n\r\n\r\nimport * as InputFilter from './inputFilter';\r\n\r\nimport * as debug from 'debug';\r\n\r\nconst debuglog = debug('erbase');\r\nconst debuglogV = debug('erbase');\r\nconst perflog = debug('perf');\r\n\r\nimport { BreakDown  as breakdown } from 'mgnlq_model';\r\n\r\nconst AnyObject = <any>Object;\r\n\r\n\r\nimport * as utils from 'abot_utils';\r\n\r\n//import { IFModel as IFModel} from 'fdevsta_monmove';\r\nimport * as IMatch from './iferbase';\r\n\r\nexport function makeError_NO_KNOWN_WORD(index : number, tokens : string[]) :IMatch.IERErrorNO_KNOWN_WORD {\r\n    if(index < 0 || index >= tokens.length) {\r\n      throw Error(\"invalid index in Error construction \" + index + \"tokens.lenth=\" + tokens.length);\r\n    }\r\n  return {\r\n    err_code: IMatch.ERR_NO_KNOWN_WORD,\r\n    text : `I do not understand \"${tokens[index]}\".`,\r\n    context : {\r\n      tokens: tokens,\r\n      token : tokens[index],\r\n      index : index\r\n    }\r\n  } as IMatch.IERErrorNO_KNOWN_WORD;\r\n}\r\n\r\n\r\nexport function makeError_EMPTY_INPUT( ) :IMatch.IERError {\r\n  return {\r\n    err_code: IMatch.ERR_EMPTY_INPUT,\r\n    text : `I did not get an input.`,\r\n  } as IMatch.IERError;\r\n}\r\n\r\nexport function explainError(errors : IMatch.IERError[]) {\r\n  if(errors.length) {\r\n    return \"\\n\" + errors.map(err => err.text).join(\"\\n\");\r\n  }\r\n  return;\r\n}"],"sourceRoot":"src"}