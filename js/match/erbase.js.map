{"version":3,"sources":["/projects/nodejs/botbuilder/mgnlq_parser1/src//projects/nodejs/botbuilder/mgnlq_parser1/src/../src/match/erbase.ts"],"names":[],"mappings":";AAAA;;;;;;;;GAQG;;AAGH,2CAA2C;AAC3C,+CAA+C;AAE/C,gCAAgC;AAIhC,IAAI,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;AAC/B,IAAI,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC;AACjC,IAAI,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;AAE5B,6CAAqD;AACrD,qCAAqC;AAErC,MAAM,SAAS,GAAQ,MAAM,CAAC;AAE9B,SAAgB,SAAS,CAAC,CAAC;IACzB,QAAQ,GAAG,CAAC,CAAC;IACb,SAAS,GAAG,CAAC,CAAC;IACd,OAAO,GAAG,CAAC,CAAC;AACd,CAAC;AAJD,8BAIC;AAGD,oCAAoC;AAGpC,6CAAiD;AAKjD,uCAAuC;AAEvC,+BAA+B;AAiC/B;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,SAAgB,cAAc,CAAC,OAAe,EAAE,KAAwB,EACtE,KAA0D;IAE1D,IAAI,GAAG,GAAG,CAAC,CAAC;IACZ,IAAI,GAAG,GAAG,CAAC,CAAC;IACZ,IAAI,MAAM,GAAG,uBAAS,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;IAC/C,IAAI,QAAQ,CAAC,OAAO,EAAE;QACpB,QAAQ,CAAC,gBAAgB,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;KACrD;IACD,iCAAiC;IACjC,KAAK,GAAG,KAAK,IAAI,EAAE,CAAC;IACpB,OAAO,CAAC,yBAAyB,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC;IAC/D,IAAI,GAAG,GAAG,EAAyC,CAAC;IACpD,IAAI,MAAM,GAAG,EAAE,CAAC;IAChB,IAAI,mBAAmB,GAAG,EAAyC,CAAC;IACpE,IAAI,aAAa,GAAG,KAAK,CAAC;IAC1B,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,KAAK,EAAE,KAAK;QAC1C,IAAI,MAAM,GAAG,SAAS,CAAC,0BAA0B,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;QACxF;;;UAGE;QACF,aAAa,GAAG,aAAa,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACvE,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,gBAAgB,KAAK,IAAI,KAAK,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;YAC5F,CAAC,CAAC,GAAG,CAAC,CAAC;QACR,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,gBAAgB,KAAK,IAAI,KAAK,MAAM;YACjE,MAAM,CAAC,GAAG,CAAE,CAAC,EAAE,EAAC,GAAG,EAAE,EAAE,GAAG,OAAO,IAAI,GAAG,KAAK,EAAE,CAAC,IAAI,CAAC,aAAa,IAAI,EAAE,CAAC,IAAI,CAAC,QAAQ,KAAK,EAAE,CAAC,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,GAAG,CAAA,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC/I,CAAC,CAAC,GAAG,CAAC,CAAC;QACR,mBAAmB,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC;QACpC,GAAG,GAAG,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC;QAC1B,GAAG,GAAG,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC;IAC5B,CAAC,CAAC,CAAC;IACH,sCAAsC;IACtC,QAAQ,CAAC,aAAa,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,WAAW,GAAG,GAAG,GAAG,QAAQ,GAAG,GAAG,CAAC,CAAC;IACpF,IAAI,QAAQ,CAAC,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE;QAC5C,QAAQ,CAAC,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;KACjE;IACD,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,oBAAoB,IAAI,CAAC,SAAS,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAC9F,IAAI,aAAa,EAAE;QACjB,4BAA4B,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,OAAO,EAAE,mBAAmB,CAAC,CAAC;KAClF;IACD,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,oBAAoB,IAAI,CAAC,SAAS,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAC9F,OAAO,CAAC,aAAa,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,KAAK,GAAG,GAAG,CAAC,MAAM,GAAG,WAAW,GAAG,GAAG,GAAG,QAAQ,GAAG,GAAG,GAAG,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;IAC3J,OAAO;QACL,OAAO,EAAE,MAAM,CAAC,OAAO;QACvB,MAAM,EAAE,MAAM,CAAC,MAAM;QACrB,gBAAgB,EAAE,mBAAmB;KACtC,CAAA;AACH,CAAC;AAhDD,wCAgDC;AAED,SAAgB,SAAS,CAAC,OAAwC,EAAE,GAAqC;IACvG,IAAG,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,KAAK,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC;WACvD,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,KAAK,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC;WAC7C,CAAC,OAAO,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC;WAC7B,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,KAAK,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE;QAC/C,OAAO,CAAC,CAAC;KACZ;IACD,IAAG,OAAO,CAAC,QAAQ,GAAG,GAAG,CAAC,QAAQ,EAAE;QAClC,OAAO,CAAC,CAAC,CAAC;KACX;IACD,OAAO,CAAC,CAAC,CAAC;AACZ,CAAC;AAXD,8BAWC;AAED,SAAgB,mBAAmB,CAAC,MAA0C,EAAE,GAAqC;IACnH,IAAI,WAAW,GAAG,CAAC,CAAC,CAAC;IACrB,IAAI,YAAY,GAAG,MAAM,CAAC,KAAK,CAAE,CAAC,OAAO,EAAC,KAAK,EAAE,EAAE;QACjD,IAAI,CAAC,GAAG,SAAS,CAAC,OAAO,EAAC,GAAG,CAAC,CAAC;QAC/B,IAAI,CAAC,GAAG,CAAC,EAAE;YACT,mGAAmG;YACnG,MAAM,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC;YACpB,OAAO,KAAK,CAAC;SACd;aAAM,IAAG,CAAC,GAAG,CAAC,EAAE;YACf,kCAAkC;YAClC,OAAO,KAAK,CAAC;SACd;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;IACH,IAAG,YAAY,EAAE;QACf,qBAAqB;QACrB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;KAClB;AACH,CAAC;AAlBD,kDAkBC;AAED,SAAgB,4BAA4B,CAAC,MAAgB,EAAE,OAAkB,EAAE,gBAAqD;IACtI,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,kCAAkC,GAAG,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAC3G,gBAAgB,CAAC,OAAO,CAAC,UAAU,QAAQ,EAAE,KAAK;QAChD,QAAQ,CAAC,OAAO,CAAC,UAAU,IAAI;YAC7B,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;gBACnB,2GAA2G;gBAC3G,IAAI,WAAW,GAAG,uBAAS,CAAC,4BAA4B,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;gBAC1F,6EAA6E;gBAC7E,IAAI,WAAW,IAAI,CAAC,EAAE;oBACpB,IAAI,YAAY,GAAG,uBAAS,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;oBAC3E,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,UAAU,YAAY,cAAc,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,aAAa,KAAK,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;oBACvJ,IAAI,GAAG,GAAG,SAAS,CAAC,4CAA4C,CAAC,YAAY,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;oBACrG,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;oBACzE,IAAI,GAAG,EAAE;wBACP,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC;wBAC1D,gBAAgB,CAAC,WAAW,CAAC,GAAG,gBAAgB,CAAC,WAAW,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,+BAA+B;wBACvG,QAAQ,CAAC,iBAAiB,WAAW,EAAE,CAAC,CAAC;wBACzC,mBAAmB,CAAC,gBAAgB,CAAC,WAAW,CAAC,EAAC,GAAG,CAAC,CAAC;wBAChE,kGAAkG;qBAC1F;iBACF;aACF;QACH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,2BAA2B;IAC3B,gBAAgB,CAAC,OAAO,CAAC,UAAU,QAAQ,EAAE,KAAK;QAChD,gBAAgB,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACtE,CAAC,CAAC,CAAC;AACL,CAAC;AA5BD,oEA4BC;AAKD,MAAM,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC;AAK9B,SAAS,cAAc,CAAC,CAAC;IACvB,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;QAC7B,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KACpB;IACD,OAAO,CAAC,CAAC;AACX,CAAC;AAGD,yCAAyC;AACzC,0CAA0C;AAC1C,WAAW;AAEX,SAAgB,SAAS,CAAC,GAAe,EAAE,KAAa;IACtD,IAAI,YAAY,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,GAAG,EAAE,EAAE,CAAC,IAAI,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACjF,OAAO,YAAY,GAAG,KAAK,CAAC;AAC9B,CAAC;AAHD,8BAGC;AAED;;;;;;;GAOG;AACH,SAAgB,6BAA6B,CAAC,MAAgB,EAAE,YAA+B;IAC7F,IAAI,CAAC,GAAG,EAAE,CAAC;IACX,IAAI,WAAW,GAAG,EAAE,CAAC;IACrB,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IACjE,YAAY,CAAC,OAAO,CAAC,UAAU,YAAY,EAAE,SAAiB;QAC5D,WAAW,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;QAC5B,YAAY,CAAC,OAAO,CAAC,UAAU,YAAY,EAAE,gBAAwB;YACnE,WAAW,CAAC,SAAS,CAAC,CAAC,gBAAgB,CAAC,GAAG,YAAY,CAAC;QAC1D,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAChE,IAAI,MAAM,GAAG;QACX,MAAM,EAAE,EAAE;QACV,MAAM,EAAE,MAAM;QACd,SAAS,EAAE,EAAE;KACgB,CAAC;IAChC,IAAI,KAAK,GAAG,EAAE,CAAC;IACf,IAAI,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC;IACf,kBAAkB;IAClB,IAAI,IAAI,GAAG,EAAE,CAAC;IACd,KAAK,IAAI,UAAU,GAAG,CAAC,EAAE,UAAU,GAAG,YAAY,CAAC,MAAM,EAAE,EAAE,UAAU,EAAE,EAAE,gBAAgB;QACzF,gEAAgE;QAChE,IAAI,QAAQ,GAAG,EAAE,CAAC;QAClB,mGAAmG;QACnG,+BAA+B;QAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YACnC,IAAI,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,EAAE;gBACjC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;aACvB;SACF;QACD,IAAI,UAAU,GAAG,YAAY,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC;QACjD,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,UAAU,KAAK,CAAC,EAAE;YAC7C,2CAA2C;YAC3C,mCAAmC;YACnC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,uBAAuB,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC,CAAC;YACxE,GAAG;SACJ;QACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,EAAE,CAAC,EAAE,EAAE,sCAAsC;YAC3E,8CAA8C;YAC9C,IAAI,KAAK,GAAG,EAAE,CAAC,CAAC,+CAA+C;YAC/D,sDAAsD;YACtD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;gBACnC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,EAAE;oBAClC,0DAA0D;oBAC1D,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,6BAA6B;oBACzD,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,cAAc,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oBAClE,6DAA6D;oBAC7D,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,CAC1B,KAAK,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,uBAAuB;oBAC9D,uEAAuE;iBACxE;aACF;YACD,kFAAkF;YAClF,+EAA+E;YAC/E,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAClC,mFAAmF;SACpF,CAAC,SAAS;QACX,uEAAuE;QACvE,GAAG,GAAG,QAAQ,CAAC;KAChB;IACD,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,kBAAkB,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAC1G,MAAM,CAAC,SAAS,GAAG,GAAG,CAAC;IACvB,OAAO,MAAM,CAAC;AAChB,CAAC;AA/DD,sEA+DC;AAED,iBAAiB;AACjB,SAAgB,WAAW,CAAC,KAAc;IACxC,OAAO,EAAE,MAAM,EAAE,KAAK;QACpB,aAAa,EAAE,KAAK;QACpB,QAAQ,EAAE,KAAK;QACf,IAAI,EACH,EAAE,QAAQ,EAAE,KAAK;YACf,IAAI,EAAE,CAAC;YACP,IAAI,EAAE,KAAK;YACX,aAAa,EAAE,KAAK,CAAC,WAAW,EAAE;YAClC,aAAa,EAAE,KAAK;YACpB,SAAS,EAAE,IAAI;YACf,QAAQ,EAAE,IAAI;YACd,cAAc,EAAE,IAAI;YACpB,QAAQ,EAAE,GAAG;YACb,QAAQ,EAAE,GAAG,EAAE;QAClB,QAAQ,EAAE,GAAG;KACd,CAAC;AACJ,CAAC;AAjBD,kCAiBC;AAED,SAAgB,mBAAmB,CAAC,GAAS,EAAE,UAAmB;IAChE,IAAG,UAAU,KAAK,CAAC,EAAE;QACnB,OAAO,KAAK,CAAC;KACd;IACD,IAAG,GAAG,CAAC,GAAG,CAAC,MAAM,GAAC,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,KAAK,GAAG,EAAE;QAC1C,IAAK,qBAAM,CAAC,0BAA0B,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,GAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;YAC9E,OAAO,IAAI,CAAC;KACf;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AATD,kDASC;AACD;;;;;;;GAOG;AACH,SAAgB,8BAA8B,CAAC,MAAgB,EAAE,YAA+B;IAC9F,IAAI,CAAC,GAAG,EAAE,CAAC;IACX,IAAI,WAAW,GAAG,EAAE,CAAC;IACrB,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IACjE,YAAY,CAAC,OAAO,CAAC,UAAU,YAAY,EAAE,SAAiB;QAC5D,WAAW,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;QAC5B,YAAY,CAAC,OAAO,CAAC,UAAU,YAAY,EAAE,gBAAwB;YACnE,WAAW,CAAC,SAAS,CAAC,CAAC,gBAAgB,CAAC,GAAG,YAAY,CAAC;QAC1D,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAChE,IAAI,MAAM,GAAG;QACX,MAAM,EAAE,EAAE;QACV,MAAM,EAAE,MAAM;QACd,SAAS,EAAE,EAAE;KACgB,CAAC;IAChC,IAAI,KAAK,GAAG,EAAE,CAAC;IACf,IAAI,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC;IACf,kBAAkB;IAClB,IAAI,IAAI,GAAG,EAAE,CAAC;IACd,KAAK,IAAI,UAAU,GAAG,CAAC,EAAE,UAAU,GAAG,YAAY,CAAC,MAAM,EAAE,EAAE,UAAU,EAAE,EAAE,gBAAgB;QACzF,yEAAyE;QACzE,IAAI,QAAQ,GAAG,EAAE,CAAC;QAClB,oGAAoG;QACpG,+BAA+B;QAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YACnC,IAAI,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,EAAE;gBACjC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;aACvB;iBAAM,IAAI,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC,EAAC,UAAU,CAAC,EAAE;gBACjD,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAC7C,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;aACvB;SACF;QACD,uFAAuF;QACvF,qGAAqG;QACrG;;;;;;UAME;QACF,IAAI,UAAU,GAAG,YAAY,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC;QACjD,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,UAAU,KAAK,CAAC,EAAE;YAC7C,2CAA2C;YAC3C,mCAAmC;YACnC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,uBAAuB,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC,CAAC;YACxE,GAAG;SACJ;QACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,EAAE,CAAC,EAAE,EAAE,sCAAsC;YAC3E,8CAA8C;YAC9C,IAAI,KAAK,GAAG,EAAE,CAAC,CAAC,+CAA+C;YAC/D,sDAAsD;YACtD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;gBACnC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC,EAAC,UAAU,CAAC,EAAE;oBAC7E,0DAA0D;oBAC1D,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,6BAA6B;oBACzD,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,cAAc,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oBAClE,6DAA6D;oBAC7D,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,CAC1B,KAAK,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,uBAAuB;oBAC9D,uEAAuE;iBACxE;aACF;YACD,kFAAkF;YAClF,+EAA+E;YAC/E,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAClC,mFAAmF;SACpF,CAAC,SAAS;QACX,uEAAuE;QACvE,GAAG,GAAG,QAAQ,CAAC;KAChB;IACD,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,kBAAkB,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAC1G,GAAG,GAAG,GAAG,CAAC,MAAM,CAAE,CAAC,QAAQ,EAAC,KAAK,EAAE,EAAE;QACnC,IAAI,IAAI,GAAG,UAAU,CAAC;QACtB,uCAAuC;QACvC,OAAO,QAAQ,CAAC,KAAK,CAAE,CAAC,IAAI,EAAC,MAAM,EAAE,EAAE;YAAG,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC;YAC/E,oHAAoH;YACpH,OAAO,IAAI,KAAK,CAAC,CAAA;QAAC,CAAC,CAAE,CAAA;IACzB,CAAC,CAAC,CAAC;IACH,MAAM,CAAC,SAAS,GAAG,GAAG,CAAC;IACvB,OAAO,MAAM,CAAC;AAChB,CAAC;AAlFD,wEAkFC;AAID,SAAgB,aAAa,CAAC,KAAa,EAAE,KAAyB,EACrE,KAA0D,EAC1D,SAAwC;IAEvC,KAAK,GAAG,KAAK,IAAI,EAAE,CAAC;IACpB,SAAS,GAAG,SAAS,IAAI,EAAE,CAAC;IAC5B,kCAAkC;IAClC,OAAO,cAAc,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC;AACxD,CAAC;AARD,sCAQC;AACC;;;;;;;;;;;;;;;;;;;;EAoBE;AAGJ,SAAgB,mBAAmB,CAAE,EAAqC,EAAE,IAAmB;IAE7F,IAAI,GAAG,GAAG,EAAyB,CAAC;IACpC,KAAK,IAAI,GAAG,IAAI,EAAE,EAClB;QACE,IAAK,GAAG,IAAI,IAAI,CAAC,MAAM,EACvB;YACE,GAAG,CAAC,IAAI,CAAE,EAAE,CAAE,GAAG,CAAE,CAAC,CAAC;SACtB;aACI,IAAK,YAAY,CAAC,YAAY,CAAC,yBAAyB,CAAE,GAAG,EAAE,IAAI,CAAC,MAAM,CAAE,EACjF;YACE,GAAG,CAAC,IAAI,CAAE,EAAE,CAAC,GAAG,CAAC,CAAE,CAAC;SACrB;KACF;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAfD,kDAeC;AAED;;;;;;;;;;;;;;;;;;;;;;;EAuBE;AACF,SAAgB,+BAA+B,CAAC,QAA2B;IACzE,IAAI,EAAE,GAAG,EAAqC,CAAC;IAC/C,IAAI,GAAG,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;QACvC,IAAI,KAAK,GAAG,mBAAmB,CAAE,EAAE,EAAE,IAAI,CAAE,CAAC;QAC5C,QAAQ,CAAC,2BAA2B,GAAG,IAAI,CAAC,MAAM,GAAG,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;QAChG,KAAK,IAAI,IAAI,IAAI,KAAK,EACtB;YACE,6BAA6B;YAC7B;;;eAGG;YACH,IAAG,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;gBAC3B,cAAc;aACf;iBACI,IAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,IAAI,CAAC,QAAQ;mBAC5C,IAAI,CAAC,IAAI,CAAC,aAAa,KAAK,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;gBACtD,QAAQ,CAAC,eAAe,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAC,SAAS,EAAC,CAAC,CAAC,CAAC,CAAC;gBACjE,OAAO,KAAK,CAAC;aAChB;SACF;QACD,IAAG,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,EACnB;YACE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;YACvB,OAAO,IAAI,CAAC;SACb;QACD,OAAO,IAAI,CAAC;IACf,CAAC,CAAC,CAAC;IACH,OAAO,GAAG,CAAC;AACZ,CAAC;AA7BD,0EA6BC;AAED,SAAgB,4BAA4B,CAAC,QAA2B,EAAG,MAAkD;IAC3H,IAAI,WAAW,GAAG,EAA+C,CAAC;IAClE,IAAI,GAAG,GAAG,CAAC,CAAC;IACZ,IAAI,KAAK,GAAE,GAAG,CAAC;IACf,IAAI,IAAI,GAAG,GAAG,CAAC;IACf,MAAM,CAAC,IAAI,CAAE,MAAM,CAAE,CAAC,OAAO,CAAE,CAAC,MAAM,EAAE,EAAE;QACxC,IAAI,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;QACzB,IAAI,GAAG,GAAG,QAAQ,CAAE,MAAM,CAAE,CAAC;QAC7B,IAAK,QAAQ,CAAC,MAAM,GAAG,GAAG,EAC1B;YACE,IAAI,IAAI,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC;YACzB,IAAI,IAAI,CAAC,MAAM,KAAK,GAAG,CAAC,MAAM;mBACzB,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,GAAG,CAAC,IAAI,CAAC,QAAQ;mBACxC,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,GAAG,CAAC,IAAI,CAAC,QAAQ;mBACxC,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,GAAG,CAAC,IAAI,CAAC,QAAQ,EAC7C;gBACE,EAAE,GAAG,CAAC;gBACN,KAAK,GAAG,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC;gBAC9B,IAAI,GAAG,IAAI,GAAG,GAAG,CAAC,QAAQ,CAAC;aAC5B;SACF;IACH,CAAC,CAAC,CAAC;IACH,IAAK,GAAG,KAAK,MAAM,CAAC,IAAI,CAAE,MAAM,CAAE,CAAC,MAAM,IAAI,KAAK,GAAG,IAAI,EACzD;QACE,OAAO,IAAI,CAAC;KACb;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AA3BD,oEA2BC;AAED,SAAS,WAAW,CAAE,MAAe,EAAE,KAAc,EAAE,QAA0B,EAAE,KAAc;IAE/F,mDAAmD;IACnD,mDAAmD;IACnD,IAAI,GAAG,GAAG,MAAM,GAAG,CAAC,CAAC;IACrB,IAAK,GAAG,IAAI,KAAK;QACd,GAAG,GAAG,CAAC,CAAC,CAAC;IACZ,GAAG,IAAI,KAAK,CAAC;IACb,IAAI,GAAG,GAAG,GAAG,GAAG,KAAK,CAAC;IACtB,OAAO,QAAQ,CAAC,GAAG,CAAC,CAAC;AACvB,CAAC;AAED,SAAgB,iBAAiB,CAAC,QAA2B,EAAE,SAA4B;IACzF,IAAI,uBAAuB,CAAC,SAAS,CAAC;QACpC,OAAO,KAAK,CAAC;IACf,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAE,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;QACtC,IAAK,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,qBAAM,CAAC,QAAQ,CAAC,QAAQ;YAChE,OAAO,IAAI,CAAC;QACd,IAAI,EAAE,GAAE,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QAC3C,IAAI,CAAC,EAAE;YACL,OAAO,IAAI,CAAC;QACd,IAAI,WAAW,GAAG,EAAE,CAAC,WAAW,IAAI,CAAC,CAAC;QACtC,IAAI,CAAC,EAAE,CAAC,KAAK;YACX,OAAO,IAAI,CAAC;QACd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,EAClC;YACE,IAAI,OAAO,GAAG,WAAW,CAAE,CAAC,EAAE,WAAW,EAAG,QAAQ,EAAE,KAAK,CAAE,CAAC;YAC9D,IAAI,CAAC,OAAO;gBACV,OAAO,KAAK,CAAC;YACf,IAAI,OAAO,GAAG,EAAE,CAAC,WAAW,CAAE,CAAC,GAAG,CAAC,CAAC,CAAC;YACrC,IAAI,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAG,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,kBAAkB,CAAE,CAAC,CAAE,CAAC,CAAC;YAC3E,IAAK,QAAQ,CAAC,OAAO,CAAE,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAE,GAAG,CAAC,EAClD;gBACE,OAAO,CAAC,GAAG,CAAE,wBAAwB,GAAG,EAAE,CAAC,QAAQ,GAAG,QAAQ,GAAG,CAAC,GAAG,WAAW,GAAG,IAAI,CAAC,SAAS,CAAE,QAAQ,CAAE,GAAG,OAAO,GAAI,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAClJ,QAAQ,CAAE,GAAE,EAAE,GAAG,OAAO,wBAAwB,GAAG,EAAE,CAAC,QAAQ,GAAG,QAAQ,GAAG,CAAC,GAAG,WAAW,GAAG,IAAI,CAAC,SAAS,CAAE,QAAQ,CAAE,GAAG,OAAO,GAAI,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA,CAAC,CAAC,CAAC;gBAC/J,OAAO,KAAK,CAAC;aACd;SACF;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;AACL,CAAC;AA5BD,8CA4BC;AAGD;;;;;;;;;;;;;;;;;;;;;;;;;;EA0BE;AACF,SAAgB,iCAAiC,CAAC,QAA2B,EAAE,SAAmC;IAChH,IAAI,EAAE,GAAG,EAAmE,CAAC;IAC7E,4CAA4C;IAC5C,IAAI,GAAG,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,EAAE;QAChC,IAAK,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,QAAQ,CAAC,YAAY;eAC5C,CAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,qBAAM,CAAC,QAAQ,CAAC,IAAI;mBAC3C,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,qBAAM,CAAC,QAAQ,CAAC,QAAQ,CAAE,EACzD;YACE,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAE;gBAC/B,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,EAA8C,CAAC;YAC/E,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;gBAClD,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,EAA0B,CAAC;YAC/E,IAAI,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC1D,IAAI,GAAG,CAAC,MAAM,IAAI,CAAC,EACnB;gBACE,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aAChB;YACD,IAAK,CAAC,GAAG,CAAC,KAAK,CAAE,CAAC,WAAW,EAAE,EAAE;gBAC/B,OAAO,YAAY,CAAC,YAAY,CAAC,yBAAyB,CAAE,IAAI,CAAC,MAAM,EAAE,WAAW,CAAC,MAAM,CAAE,CAAC;YAChG,CAAC,CAAC,EACF;gBACE,GAAG,CAAC,IAAI,CAAE,IAAI,CAAE,CAAC;aAClB;SACF;QACD,4DAA4D;QAC5D,IAAI,YAAY,GAAG,EAAmE,CAAC;QACvF,MAAM,CAAC,IAAI,CAAE,EAAE,CAAE,CAAC,OAAO,CAAE,CAAC,GAAG,EAAE,EAAE;YACjC,IAAI,KAAK,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC;YACpB,MAAM,CAAC,IAAI,CAAE,KAAK,CAAE,CAAC,OAAO,CAAE,CAAC,WAAW,EAAE,EAAE;gBAC5C,IAAK,KAAK,CAAC,WAAW,CAAC,CAAC,MAAM,GAAG,CAAC,EAClC;oBACE,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC;wBACpB,YAAY,CAAC,GAAG,CAAC,GAAG,EAA8C,CAAC;oBACrE,YAAY,CAAC,GAAG,CAAC,CAAC,WAAW,CAAC,GAAG,KAAK,CAAC,WAAW,CAAC,CAAC;iBACrD;YACH,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QACH,OAAO,MAAM,CAAC,IAAI,CAAE,YAAY,CAAE,CAAC,KAAK,CAAE,CAAC,GAAG,EAAE,EAAE;YAChD,OAAO,MAAM,CAAC,IAAI,CAAE,YAAY,CAAE,GAAG,CAAE,CAAE,CAAC,KAAK,CAAE,CAAE,EAAE,EAAG,EAAE;gBACxD,IAAI,GAAG,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;gBAChC,IAAI,MAAM,GAAG,EAA+C,CAAC;gBAC7D,0BAA0B;gBAC1B,0DAA0D;gBAC1D,KAAK,IAAI,IAAI,IAAI,GAAG,EACpB;oBACE,IAAI,GAAG,GAAG,QAAQ,CAAC,OAAO,CAAE,IAAI,CAAE,CAAC;oBACnC,IAAK,GAAG,GAAG,CAAC;wBACV,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;oBACrD,MAAM,CAAE,GAAG,CAAE,GAAG,IAAI,CAAC;iBACtB;gBACD;;;;4BAIY;gBACZ,OAAO,SAAS,CAAC,KAAK,CAAE,CAAC,aAAa,EAAE,EAAE;oBACxC,IAAI,aAAa,KAAK,QAAQ;wBAC5B,OAAO,IAAI,CAAC;oBACd,IAAK,4BAA4B,CAAE,aAAa,EAAE,MAAM,CAAC,EACzD;wBACE,QAAQ,CAAC,8CAA8C,GAAI,QAAQ,CAAC,2BAA2B,CAAC,QAAQ,CAAC;8BACvG,MAAM,GAAG,QAAQ,CAAC,2BAA2B,CAAE,aAAa,CAAE,GAAG,kBAAkB,CAAC,CAAC;wBACvF,OAAO,KAAK,CAAC;qBACd;oBACD,OAAO,IAAI,CAAC;gBACd,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAA;QACJ,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,QAAQ,CAAC,YAAY,GAAG,CAAC,GAAG,GAAG,GAAG,GAAI,QAAQ,CAAC,2BAA2B,CAAC,QAAQ,CAAC,CAAE,CAAC;IACvF,OAAO,CAAC,GAAG,CAAC;AACd,CAAC;AAvED,8EAuEC;AAGD;;;;;;;;;;;GAWG;AACH,SAAgB,kCAAkC,CAAC,QAA2B;IAC5E,IAAI,EAAE,GAAG,EAAqC,CAAC;IAC/C,IAAI,GAAG,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;QACvC,IAAI,IAAI,GAAG,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC3B,IAAG,CAAC,IAAI,EACR,EAAE,cAAc;YACd;;;;cAIE;SACH;QACD,IAAG,CAAC,IAAI,EAAE;YACR,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;YACvB,OAAO,IAAI,CAAC;SACb;QACD,IAAG,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;YAC3B,OAAO,IAAI,CAAC;SACb;QACD,IAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,IAAI,CAAC,QAAQ;eACvC,IAAI,CAAC,IAAI,CAAC,aAAa,KAAK,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;YACxD,wEAAwE;YACtE,OAAO,KAAK,CAAC;SAChB;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;IACH,OAAO,GAAG,CAAC;AACb,CAAC;AA3BD,gFA2BC;AAED,SAAgB,4BAA4B,CAAC,UAAwC;IACnF,IAAI,YAAY,GAAG,EAAmB,CAAC;IACvC,IAAI,GAAG,GAAI,MAAc,CAAC,MAAM,CAAE,EAAE,EAAE,UAAU,CAAE,CAAC;IACnD,GAAG,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAC,KAAK,EAAE,EAAE;QAC7D,IAAG,CAAC,+BAA+B,CAAC,QAAQ,CAAC,EAAE;YAC7C,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACzB,OAAO,KAAK,CAAC;SACd;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;IACH,IAAG,YAAY,CAAC,MAAM,EAAE;QACtB,GAAG,CAAC,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,MAAM,CAAE,CAAC,KAAK,EAAC,KAAK,EAAE,EAAE;YACrD,IAAG,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;gBACnC,OAAO,KAAK,CAAC;aACd;YACD,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;KACJ;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAnBD,oEAmBC;AAED,SAAS,uBAAuB,CAAC,GAAG;IAClC,OAAO,CAAC,GAAG,KAAK,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;AAChE,CAAC;AAGD,SAAgB,qBAAqB,CAAC,UAAwC,EAAE,SAA8B;IAC5G,IAAK,uBAAuB,CAAC,SAAS,CAAC;QACrC,OAAO,UAAU,CAAC;IACpB,IAAI,YAAY,GAAG,EAAmB,CAAC;IACvC,IAAI,GAAG,GAAI,MAAc,CAAC,MAAM,CAAE,EAAE,EAAE,UAAU,CAAE,CAAC;IACnD,GAAG,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAC,KAAK,EAAE,EAAE;QAC7D,IAAG,iBAAiB,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE;YACzC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACzB,OAAO,KAAK,CAAC;SACd;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;IACH,IAAG,YAAY,CAAC,MAAM,EAAE;QACtB,GAAG,CAAC,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,MAAM,CAAE,CAAC,KAAK,EAAC,KAAK,EAAE,EAAE;YACrD,IAAG,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;gBACnC,OAAO,KAAK,CAAC;aACd;YACD,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;KACJ;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AArBD,sDAqBC;AAGD,SAAgB,mCAAmC,CAAC,UAAwC;IAC1F,IAAI,YAAY,GAAG,EAAmB,CAAC;IACvC,IAAI,GAAG,GAAI,MAAc,CAAC,MAAM,CAAE,EAAE,EAAE,UAAU,CAAE,CAAC;IACnD,GAAG,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAC,KAAK,EAAE,EAAE;QAC7D,IAAG,iCAAiC,CAAC,QAAQ,EAAE,UAAU,CAAC,SAAS,CAAC,EAAE;YACpE,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACzB,OAAO,KAAK,CAAC;SACd;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;IACH,IAAG,YAAY,CAAC,MAAM,EAAE;QACtB,GAAG,CAAC,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,MAAM,CAAE,CAAC,KAAK,EAAC,KAAK,EAAE,EAAE;YACrD,IAAG,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;gBACnC,OAAO,KAAK,CAAC;aACd;YACD,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;KACJ;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAnBD,kFAmBC;AAED,SAAgB,cAAc,CAAC,KAAa,EAAE,KAAyB,EACtE,KAA0D,EAC1D,SAAwC;IAEvC,KAAK,GAAG,KAAK,IAAI,EAAE,CAAC;IACpB,IAAI,WAAW,GAAG,cAAc,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;IACtD,QAAQ,CAAC,GAAE,EAAE,CAAC,cAAc,GAAG,WAAW,CAAC,gBAAgB,CAAC,GAAG,CAAE,CAAC,CAAC,EAAE,CAAC,QAAQ,CAAC,2BAA2B,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IACvI,4BAA4B,CAAC,WAAW,CAAC,MAAM,EAAE,WAAW,CAAC,OAAO,EAClE,WAAW,CAAC,gBAAgB,CAAC,CAAC;IAChC,SAAS,CAAC,GAAE,EAAE,CAAA,gBAAgB,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,gBAAgB,CAAC,CAAC,CAAC;IAC/E,IAAI,UAAU,GAAG,8BAA8B,CAAC,WAAW,CAAC,MAAM,EAAE,WAAW,CAAC,gBAAgB,CAAC,CAAC;IAClG,QAAQ,CAAC,GAAG,EAAE,CAAC,eAAe,GAAG,UAAU,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,SAAS;QAC3E,OAAO,QAAQ,CAAC,cAAc,CAAC,SAAS,CAAC,GAAG,KAAK,GAAG,QAAQ,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC,CAAC,4BAA4B;IACxH,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IACjB,UAAU,GAAG,qBAAqB,CAAC,UAAU,EAAE,SAAS,CAAC,CAAA;IACzD,UAAU,GAAG,4BAA4B,CAAC,UAAU,CAAC,CAAC;IAEtD,UAAU,GAAG,mCAAmC,CAAC,UAAU,CAAC,CAAC;IAE7D,UAAU,CAAC,SAAS,GAAG,SAAS,CAAC,SAAS,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;IACjE,SAAS,CAAC,GAAE,EAAE,CAAC,mBAAmB,GAAG,UAAU,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,SAAS;QAC7E,OAAO,QAAQ,CAAC,cAAc,CAAC,SAAS,CAAC,GAAG,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;IAChF,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IACjB,QAAQ,CAAC,GAAG,EAAE,CAAC,iBAAiB,GAAG,UAAU,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,SAAS;QAC7E,OAAO,QAAQ,CAAC,cAAc,CAAC,SAAS,CAAC,GAAG,KAAK,GAAG,QAAQ,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC,CAAC,4BAA4B;IACxH,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IACjB,OAAO,UAAU,CAAC;AACpB,CAAC;AA3BD,wCA2BC","file":"erbase.js","sourcesContent":["/**\n *\n * @module jfseb.erbase\n * @file erbase\n * @copyright (c) 2016 Gerd Forstmann\n *\n * Basic domain based entity recognition\n *\n */\n\n\nimport * as WordMatch from './inputFilter';\nimport * as CharSequence from './charsequence';\n\nimport * as debug from 'debugf';\n\n\n\nvar debuglog = debug('erbase');\nvar debuglogV = debug('erVbase');\nvar perflog = debug('perf');\n\nimport { BreakDown as breakdown}  from 'mgnlq_model';\nimport * as ERError from './ererror';\n\nconst AnyObject = <any>Object;\n\nexport function mockDebug(o) {\n  debuglog = o;\n  debuglogV = o;\n  perflog = o;\n}\n\n\nimport * as utils from 'abot_utils';\n\nimport * as IFErBase from './iferbase';\nimport { IFModel  as IMatch}  from 'mgnlq_model';\nimport { IFModel  as IFModel}  from 'mgnlq_model';\n\n\n\nimport * as Sentence from './sentence';\n\nimport * as Word from './word';\n\nimport * as Algol from './algol';\nimport { AssertionError } from 'assert';\nimport { IOperator } from 'mgnlq_model/js/match/ifmatch';\n\n\n//import * as Match from './match';\n\n\nexport interface ITokenizedString {\n  tokens: string[],\n  categorizedWords: IMatch.ICategorizedStringRanged[][]\n  fusable: boolean[];\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Given a  string, break it down into components,\n * [['A', 'B'], ['A B']]\n *\n * then categorizeWords\n * returning\n *\n * [ [[ { category: 'systemId', word : 'A'},\n *      { category: 'otherthing', word : 'A'}\n *    ],\n *    // result of B\n *    [ { category: 'systemId', word : 'B'},\n *      { category: 'otherthing', word : 'A'}\n *      { category: 'anothertryp', word : 'B'}\n *    ]\n *   ],\n * ]]]\n *\n *\n *\n */\nexport function tokenizeString(sString: string, rules: IMatch.SplitRules,\n  words: { [key: string]: Array<IMatch.ICategorizedString> })\n  : ITokenizedString {\n  var cnt = 0;\n  var fac = 1;\n  var tokens = breakdown.tokenizeString(sString);\n  if (debuglog.enabled) {\n    debuglog(\"here breakdown\" + JSON.stringify(tokens));\n  }\n  //console.log(JSON.stringify(u));\n  words = words || {};\n  perflog('this many known words: ' + Object.keys(words).length);\n  var res = [] as IMatch.ICategorizedStringRanged[][];\n  var cntRec = {};\n  var categorizedSentence = [] as IMatch.ICategorizedStringRanged[][];\n  var hasRecombined = false;\n  tokens.tokens.forEach(function (token, index) {\n    var seenIt = WordMatch.categorizeAWordWithOffsets(token, rules, sString, words, cntRec);\n    /* cannot have this, or need to add all fragment words \"UI2 Integration\"  if(seenIt.length === 0) {\n          return false;\n        }\n    */\n    hasRecombined = hasRecombined || !seenIt.every(res => !res.rule.range);\n    debuglogV(debuglogV.enabled ? (` categorized ${token}/${index} to ` + JSON.stringify(seenIt))\n     : \"-\");\n    debuglog(debuglog.enabled ? (` categorized ${token}/${index} to ` +\n    seenIt.map( (it,idx) => { return ` ${idx}  ${it.rule.matchedString}/${it.rule.category}  ${it.rule.wordType}${it.rule.bitindex} ` }).join(\"\\n\"))\n     : \"-\");\n    categorizedSentence[index] = seenIt;\n    cnt = cnt + seenIt.length;\n    fac = fac * seenIt.length;\n  });\n  // have seen the plain categorization,\n  debuglog(\" sentences \" + tokens.tokens.length + \" matches \" + cnt + \" fac: \" + fac);\n  if (debuglog.enabled && tokens.tokens.length) {\n    debuglog(\"first match \" + JSON.stringify(tokens, undefined, 2));\n  }\n  debuglog(debuglog.enabled ? ` prior RangeRule ${JSON.stringify(categorizedSentence)} ` : '-');\n  if (hasRecombined) {\n    evaluateRangeRulesToPosition(tokens.tokens, tokens.fusable, categorizedSentence);\n  }\n  debuglog(debuglog.enabled ? ` after RangeRule ${JSON.stringify(categorizedSentence)} ` : '-');\n  perflog(\" sentences \" + tokens.tokens.length + \" / \" + res.length + \" matches \" + cnt + \" fac: \" + fac + \" rec : \" + JSON.stringify(cntRec, undefined, 2));\n  return {\n    fusable: tokens.fusable,\n    tokens: tokens.tokens,\n    categorizedWords: categorizedSentence\n  }\n}\n\nexport function isSameRes(present: IMatch.ICategorizedStringRanged, res : IMatch.ICategorizedStringRanged)  : number {\n  if(!((present.rule.matchedString === res.rule.matchedString)\n    && (present.rule.category === res.rule.category)\n    && (present.span === res.span)\n  && (present.rule.bitindex === res.rule.bitindex))) {\n      return 0;\n  }\n  if(present._ranking < res._ranking) {\n    return -1;\n  }\n  return +1;\n}\n\nexport function mergeIgnoreOrAppend(result : IMatch.ICategorizedStringRanged[], res : IMatch.ICategorizedStringRanged) {\n  var insertindex = -1;\n  var foundNothing = result.every( (present,index) => {\n    var r = isSameRes(present,res);\n    if (r < 0) {\n      //console.log(\"overwriting worse \\n\" + JSON.stringify(res) + '\\n' + JSON.stringify(present)+ '\\n');\n      result[index] = res;\n      return false;\n    } else if(r > 0) {\n      //console.log('skipping present');\n      return false;\n    }\n    return true;\n  });\n  if(foundNothing) {\n    //debulog('pushing');\n    result.push(res);\n  }\n}\n\nexport function evaluateRangeRulesToPosition(tokens: string[], fusable: boolean[], categorizedWords: IMatch.ICategorizedStringRanged[][]) {\n  debuglog(debuglog.enabled ? (\"evaluateRangeRulesToPosition... \" + JSON.stringify(categorizedWords)) : '-');\n  categorizedWords.forEach(function (wordlist, index) {\n    wordlist.forEach(function (word) {\n      if (word.rule.range) {\n        //console.log(` got targetindex for RangeRules evaluation : ${targetIndex} ${index} ${fusable.join(\" \")}`);\n        var targetIndex = breakdown.isCombinableRangeReturnIndex(word.rule.range, fusable, index);\n        //console.log(` got targetindex for RangeRules evaluation : ${targetIndex}`);\n        if (targetIndex >= 0) {\n          var combinedWord = breakdown.combineTokens(word.rule.range, index, tokens);\n          debuglog(debuglog.enabled ? (` test \"${combinedWord}\" against \"${word.rule.range.rule.lowercaseword}\" ${JSON.stringify(word.rule.range.rule)}`) : '-');\n          var res = WordMatch.categorizeWordWithOffsetWithRankCutoffSingle(combinedWord, word.rule.range.rule);\n          debuglog(debuglog.enabled ? (\" got res : \" + JSON.stringify(res)) : '-');\n          if (res) {\n            res.span = word.rule.range.high - word.rule.range.low + 1;\n            categorizedWords[targetIndex] = categorizedWords[targetIndex].slice(0); // avoid invalidation of seenit\n            debuglog(`pushed sth at ${targetIndex}`);\n            mergeIgnoreOrAppend(categorizedWords[targetIndex],res);\n   //         categorizedWords[targetIndex].push(res); // check that this does not invalidate seenit!\n          }\n        }\n      }\n    });\n  });\n  // filter all range rules !\n  categorizedWords.forEach(function (wordlist, index) {\n    categorizedWords[index] = wordlist.filter(word => !word.rule.range);\n  });\n}\n\n\n\n\nconst clone = utils.cloneDeep;\n\n\n\n\nfunction copyVecMembers(u) {\n  var i = 0;\n  for (i = 0; i < u.length; ++i) {\n    u[i] = clone(u[i]);\n  }\n  return u;\n}\n\n\n// we can replicate the tail or the head,\n// we replicate the tail as it is smaller.\n// [a,b,c ]\n\nexport function isSpanVec(vec: Array<any>, index: number) {\n  var effectivelen = vec.reduce((prev, mem) => prev += mem.span ? mem.span : 1, 0);\n  return effectivelen > index;\n}\n\n/**\n * expand an array [[a1,a2], [b1,b2],[c]]\n * into all combinations\n *\n *  if a1 has a span of three, the variations of the lower layer are skipped\n *\n * with the special property\n */\nexport function expandTokenMatchesToSentences(tokens: string[], tokenMatches: Array<Array<any>>): IMatch.IProcessedSentences {\n  var a = [];\n  var wordMatches = [];\n  debuglogV(debuglog.enabled ? JSON.stringify(tokenMatches) : '-');\n  tokenMatches.forEach(function (aWordMatches, wordIndex: number) {\n    wordMatches[wordIndex] = [];\n    aWordMatches.forEach(function (oWordVariant, wordVariantIndex: number) {\n      wordMatches[wordIndex][wordVariantIndex] = oWordVariant;\n    });\n  });\n  debuglog(debuglog.enabled ? JSON.stringify(tokenMatches) : '-');\n  var result = {\n    errors: [],\n    tokens: tokens,\n    sentences: []\n  } as IMatch.IProcessedSentences;\n  var nvecs = [];\n  var res = [[]];\n  // var nvecs = [];\n  var rvec = [];\n  for (var tokenIndex = 0; tokenIndex < tokenMatches.length; ++tokenIndex) { // wordg index k\n    //vecs is the vector of all so far seen variants up to k length.\n    var nextBase = [];\n    //independent of existence of matches on level k, we retain all vectors which are covered by a span\n    // we skip extending them below\n    for (var u = 0; u < res.length; ++u) {\n      if (isSpanVec(res[u], tokenIndex)) {\n        nextBase.push(res[u]);\n      }\n    }\n    var lenMatches = tokenMatches[tokenIndex].length;\n    if (nextBase.length === 0 && lenMatches === 0) {\n      // the word at index I cannot be understood\n      //if (result.errors.length === 0) {\n      result.errors.push(ERError.makeError_NO_KNOWN_WORD(tokenIndex, tokens));\n      //}\n    }\n    for (var l = 0; l < lenMatches; ++l) { // for each variant present at index k\n      //debuglog(\"vecs now\" + JSON.stringify(vecs));\n      var nvecs = []; //vecs.slice(); // copy the vec[i] base vector;\n      //debuglog(\"vecs copied now\" + JSON.stringify(nvecs));\n      for (var u = 0; u < res.length; ++u) {\n        if (!isSpanVec(res[u], tokenIndex)) {\n          // for each so far constructed result (of length k) in res\n          nvecs.push(res[u].slice()); // make a copy of each vector\n          nvecs[nvecs.length - 1] = copyVecMembers(nvecs[nvecs.length - 1]);\n          // debuglog(\"copied vecs[\"+ u+\"]\" + JSON.stringify(vecs[u]));\n          nvecs[nvecs.length - 1].push(\n            clone(tokenMatches[tokenIndex][l])); // push the lth variant\n          // debuglog(\"now nvecs \" + nvecs.length + \" \" + JSON.stringify(nvecs));\n        }\n      }\n      //   debuglog(\" at     \" + k + \":\" + l + \" nextbase >\" + JSON.stringify(nextBase))\n      //   debuglog(\" append \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nvecs))\n      nextBase = nextBase.concat(nvecs);\n      //   debuglog(\"  result \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nextBase))\n    } //constru\n    //  debuglog(\"now at \" + k + \":\" + l + \" >\" + JSON.stringify(nextBase))\n    res = nextBase;\n  }\n  debuglogV(debuglogV.enabled ? (\"APPENDING TO RES\" + 0 + \":\" + l + \" >\" + JSON.stringify(nextBase)) : '-');\n  result.sentences = res;\n  return result;\n}\n\n// todo: bitindex\nexport function makeAnyWord(token : string) {\n  return { string: token,\n    matchedString: token,\n    category: 'any',\n    rule:\n     { category: 'any',\n       type: 0,\n       word: token,\n       lowercaseword: token.toLowerCase(),\n       matchedString: token,\n       exactOnly: true,\n       bitindex: 4096,\n       bitSentenceAnd: 4095,\n       wordType: 'A', // IMatch.WORDTYPE.ANY,\n       _ranking: 0.9 },\n    _ranking: 0.9\n  };\n}\n\nexport function isSuccessorOperator(res : any, tokenIndex : number) : boolean {\n  if(tokenIndex === 0) {\n    return false;\n  }\n  if(res[res.length-1].rule.wordType === 'O') {\n    if ( IMatch.aAnySuccessorOperatorNames.indexOf(res[res.length-1].rule.word) >= 0)\n      return true;\n  }\n  return false;\n}\n/**\n * expand an array [[a1,a2], [b1,b2],[c]]\n * into all combinations\n *\n *  if a1 has a span of three, the variations of the lower layer are skipped\n *\n * with the special property\n */\nexport function expandTokenMatchesToSentences2(tokens: string[], tokenMatches: Array<Array<any>>): IMatch.IProcessedSentences {\n  var a = [];\n  var wordMatches = [];\n  debuglogV(debuglog.enabled ? JSON.stringify(tokenMatches) : '-');\n  tokenMatches.forEach(function (aWordMatches, wordIndex: number) {\n    wordMatches[wordIndex] = [];\n    aWordMatches.forEach(function (oWordVariant, wordVariantIndex: number) {\n      wordMatches[wordIndex][wordVariantIndex] = oWordVariant;\n    });\n  });\n  debuglog(debuglog.enabled ? JSON.stringify(tokenMatches) : '-');\n  var result = {\n    errors: [],\n    tokens: tokens,\n    sentences: []\n  } as IMatch.IProcessedSentences;\n  var nvecs = [];\n  var res = [[]];\n  // var nvecs = [];\n  var rvec = [];\n  for (var tokenIndex = 0; tokenIndex < tokenMatches.length; ++tokenIndex) { // wordg index k\n    //vecs is the vector of all so far seen variants up to tokenIndex length.\n    var nextBase = [];\n    // independent of existence of matches on level k, we retain all vectors which are covered by a span\n    // we skip extending them below\n    for (var u = 0; u < res.length; ++u) {\n      if (isSpanVec(res[u], tokenIndex)) {\n        nextBase.push(res[u]);\n      } else if( isSuccessorOperator(res[u],tokenIndex)) {\n        res[u].push(makeAnyWord(tokens[tokenIndex]));\n        nextBase.push(res[u]);\n      }\n    }\n    // independent of existence of matches on level tokenIndex, we extend all vectors which\n    // are a successor of a binary extending op ( like \"starting with\", \"containing\" with the next token)\n    /*   for(var resIndex = 0; resIndex < res.length; ++resIndex) {\n      if (isSuccessorOperator(res[resIndex], tokenIndex)) {\n        res[resIndex].push(makeAnyWord(tokens[tokenIndex]));\n        nextBase.push(res[resIndex]);\n      }\n    }\n    */\n    var lenMatches = tokenMatches[tokenIndex].length;\n    if (nextBase.length === 0 && lenMatches === 0) {\n      // the word at index I cannot be understood\n      //if (result.errors.length === 0) {\n      result.errors.push(ERError.makeError_NO_KNOWN_WORD(tokenIndex, tokens));\n      //}\n    }\n    for (var l = 0; l < lenMatches; ++l) { // for each variant present at index k\n      //debuglog(\"vecs now\" + JSON.stringify(vecs));\n      var nvecs = []; //vecs.slice(); // copy the vec[i] base vector;\n      //debuglog(\"vecs copied now\" + JSON.stringify(nvecs));\n      for (var u = 0; u < res.length; ++u) {\n        if (!isSpanVec(res[u], tokenIndex) && !isSuccessorOperator(res[u],tokenIndex)) {\n          // for each so far constructed result (of length k) in res\n          nvecs.push(res[u].slice()); // make a copy of each vector\n          nvecs[nvecs.length - 1] = copyVecMembers(nvecs[nvecs.length - 1]);\n          // debuglog(\"copied vecs[\"+ u+\"]\" + JSON.stringify(vecs[u]));\n          nvecs[nvecs.length - 1].push(\n            clone(tokenMatches[tokenIndex][l])); // push the lth variant\n          // debuglog(\"now nvecs \" + nvecs.length + \" \" + JSON.stringify(nvecs));\n        }\n      }\n      //   debuglog(\" at     \" + k + \":\" + l + \" nextbase >\" + JSON.stringify(nextBase))\n      //   debuglog(\" append \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nvecs))\n      nextBase = nextBase.concat(nvecs);\n      //   debuglog(\"  result \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nextBase))\n    } //constru\n    //  debuglog(\"now at \" + k + \":\" + l + \" >\" + JSON.stringify(nextBase))\n    res = nextBase;\n  }\n  debuglogV(debuglogV.enabled ? (\"APPENDING TO RES\" + 0 + \":\" + l + \" >\" + JSON.stringify(nextBase)) : '-');\n  res = res.filter( (sentence,index) => {\n    var full = 0xFFFFFFFF;\n    //console.log(`sentence  ${index}  \\n`)\n    return sentence.every( (word,index2) => { full = full & word.rule.bitSentenceAnd;\n      //console.log(` word  ${index2} ${full} \"${word.matchedString}\" ${word.rule.bitSentenceAnd}  ${tokens[index2]} \\n`);\n      return full !== 0 } )\n  });\n  result.sentences = res;\n  return result;\n}\n\n\n\nexport function processString(query: string, rules: IFModel.SplitRules,\n words: { [key: string]: Array<IMatch.ICategorizedString> },\n operators : { [key:string] : IOperator }\n):  IMatch.IProcessedSentences {\n  words = words || {};\n  operators = operators || {};\n  //if(!process.env.ABOT_NO_TEST1) {\n  return processString2(query, rules, words, operators);\n}\n  /*\n  var tokenStruct = tokenizeString(query, rules, words);\n  evaluateRangeRulesToPosition(tokenStruct.tokens, tokenStruct.fusable,\n    tokenStruct.categorizedWords);\n  if (debuglog.enabled) {\n    debuglog(\"After matched \" + JSON.stringify(tokenStruct.categorizedWords));\n  }\n  var aSentences = expandTokenMatchesToSentences(tokenStruct.tokens, tokenStruct.categorizedWords);\n  if (debuglog.enabled) {\n    debuglog(\"after expand\" + aSentences.sentences.map(function (oSentence) {\n    return Sentence.rankingProduct(oSentence) + \":\" + Sentence.dumpNice(oSentence); //JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  }\n  aSentences.sentences = WordMatch.reinForce(aSentences.sentences);\n  if (debuglog.enabled) {\n    debuglog(\"after reinforce\" + aSentences.sentences.map(function (oSentence) {\n      return Sentence.rankingProduct(oSentence) + \":\" + JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  }\n  return aSentences;\n  */\n\n\nexport function findCloseIdenticals( mp :  {[key : string] : IMatch.IWord}, word : IMatch.IWord ) : Array<IMatch.IWord>\n{\n  var res = [] as Array<IMatch.IWord>;\n  for( var key in mp )\n  {\n    if ( key == word.string )\n    {\n      res.push( mp[ key ]);\n    }\n    else if ( CharSequence.CharSequence.isSameOrPluralOrVeryClose( key, word.string ) )\n    {\n      res.push( mp[key] );\n    }\n  }\n  return res;\n}\n\n/* Return true if the identical *source word* is interpreted\n* (within the same domain and the same wordtype)\n* as a differnent  (e.g. element numb is one interpreted as 'CAT' element name, once as CAT 'element number' in\n*\n* example\n* [ 'element names=>element number/category/2 F16',         <<< (1)\n*    'element number=>element number/category/2 F16',\n*    'element weight=>atomic weight/category/2 F16',\n*    'element name=>element name/category/2 F16',           <<< (2)\n*    'with=>with/filler I256',\n*    'element name=>element name/category/2 F16',           <<< (3)\n*   'starting with=>starting with/operator/2 O256',\n*    'ABC=>ABC/any A4096' ],\n*\n* same domain IUPAC elements)\n*\n*  (1) differs to (2),(3) although the base words are very similar element names, element name, element name respectively\n*\n* - exact match\n* - stemming by removing/appending traling s\n* - closeness\n*\n* @param sentence\n*/\nexport function isDistinctInterpretationForSame(sentence : IMatch.ISentence) : boolean {\n  var mp = {} as {[key : string] : IMatch.IWord};\n  var res = sentence.every((word, index) => {\n    var seens = findCloseIdenticals( mp, word );\n    debuglog(\" investigating seens for \" + word.string + \" \" + JSON.stringify(seens, undefined, 2));\n    for( var seen of seens)\n    {\n      //var seen = mp[word.string];\n      /*if(!seen) {\n        mp[word.string] = word;\n        return true;\n      }*/\n      if(!seen.rule || !word.rule) {\n        //return true;\n      }\n      else if(seen.rule.bitindex === word.rule.bitindex\n        && seen.rule.matchedString !== word.rule.matchedString ){\n          debuglog(\"skipping this\" + JSON.stringify(sentence,undefined,2));\n          return false;\n      }\n    }\n    if(!mp[word.string])\n    {\n      mp[word.string] = word;\n      return true;\n    }\n    return true;\n });\n return res;\n}\n\nexport function isSameCategoryAndHigherMatch(sentence : IMatch.ISentence,  idxmap : { [akey : number] : Array<IMatch.IWord> }) : boolean {\n  var idxmapother = {} as { [akey : number] : Array<IMatch.IWord> };\n  var cnt = 0;\n  var prodo =1.0;\n  var prod = 1.0;\n  Object.keys( idxmap ).forEach( (idxkey) => {\n    var wrd = idxmap[idxkey];\n    var idx = parseInt( idxkey );\n    if ( sentence.length > idx )\n    {\n      var wrdo = sentence[idx];\n      if( wrdo.string === wrd.string\n        && wrdo.rule.bitindex === wrd.rule.bitindex\n        && wrdo.rule.wordType === wrd.rule.wordType\n        && wrdo.rule.category === wrd.rule.category )\n      {\n        ++cnt;\n        prodo = prodo * wrdo._ranking;\n        prod = prod * wrd._ranking;\n      }\n    }\n  });\n  if ( cnt === Object.keys( idxmap ).length && prodo > prod )\n  {\n    return true;\n  }\n  return false;\n}\n\nfunction get_ith_arg( onepos : number, oppos : number, sentence: IMatch.ISentence, index : number ) : IMatch.IWord\n{ ///         oppos=0     oppos=-1     oppos=-2   oppos=1\n  // 1 ->  0  -1;           1            2         -2\n  // 2  -> 1   1;           2            3         -1\n  var pos = onepos - 1;\n  if ( pos <= oppos )\n     pos = -1;\n  pos -= oppos;\n  var idx = pos + index;\n  return sentence[idx];\n}\n\nexport function isBadOperatorArgs(sentence : IMatch.ISentence, operators: IMatch.IOperators ) : boolean {\n  if (isNullOrEmptyDictionary(operators))\n    return false;\n  return !sentence.every( (word, index) => {\n    if(  (word.rule && word.rule.wordType) != IMatch.WORDTYPE.OPERATOR )\n      return true;\n    var op =operators[word.rule.matchedString];\n    if( !op)\n      return true;\n    var operatorpos = op.operatorpos || 0;\n    if (!op.arity)\n      return true;\n    for( var i = 1; i <= op.arity; ++i)\n    {\n      var ith_arg = get_ith_arg( i, operatorpos , sentence, index );\n      if (!ith_arg)\n        return false;\n      var argtype = op.argcategory[ i - 1];\n      var argtypex = argtype.map(  (x) => Word.WordType.fromCategoryString( x ));\n      if ( argtypex.indexOf( ith_arg.rule.wordType ) < 0 )\n      {\n        console.log( \"discarding due to arg \" + op.operator + \" arg #\" + i + \" expected\" + JSON.stringify( argtypex ) + \" was \"  + ith_arg.rule.wordType);\n        debuglog( ()=> { return \"discarding due to arg \" + op.operator + \" arg #\" + i + \" expected\" + JSON.stringify( argtypex ) + \" was \"  + ith_arg.rule.wordType;});\n        return false;\n      }\n    }\n    return true;\n  });\n}\n\n\n/* Return true if the identical *target word* is expressed by different source words\n* (within the same domain and the same wordtype)\n*\n* this is problematic with aliases mapped onto the same target, (eg. where -> with, with -> where )\n* so perhaps only for categories and facts?\n*\n* example <pre>\n* [ 'element names=>element number/category/2 C8',         <<< (1a)\n*    'element number=>element number/category/2 C8',       <<< (2)\n*    'element weight=>atomic weight/category/2 C8',\n*    'element name=>element number/category/2 C8',           <<< (1b)\n*    'with=>with/filler I256',\n*    'element name=>element number/category/2 C8',           <<< (1c)\n*    'starting with=>starting with/operator/2 O256',\n*    'ABC=>ABC/any A4096' ],\n*\n* same domain IUPAC elements)\n*\n*  (1abc) differs from (2),\n*  and there is a much better interpretation around\n* </pre>\n* - exact match\n* - stemming by removing/appending traling s\n* - closeness\n*\n* @param sentence\n*/\nexport function isNonOptimalDistinctSourceForSame(sentence : IMatch.ISentence, sentences : Array<IMatch.ISentence>) : boolean {\n  var mp = {} as {[key : string] :  { [key : number] : Array<IMatch.IWord> } };\n  // calculate conflicts :    [taget_word -> ]\n  var res = sentence.every((word) => {\n    if ( word.category === Word.Category.CAT_CATEGORY\n      && (  word.rule.wordType === IMatch.WORDTYPE.FACT\n         || word.rule.wordType === IMatch.WORDTYPE.CATEGORY ))\n    {\n      if (!mp[word.rule.matchedString ])\n        mp[word.rule.matchedString] = {} as { [key : number] : Array<IMatch.IWord> };\n      if( !mp[word.rule.matchedString][word.rule.bitindex])\n        mp[word.rule.matchedString][word.rule.bitindex] = [] as  Array<IMatch.IWord>;\n      var arr = mp[word.rule.matchedString][word.rule.bitindex];\n      if( arr.length == 0 )\n      {\n        arr.push(word);\n      }\n      if ( !arr.every( (presentword) => {\n        return CharSequence.CharSequence.isSameOrPluralOrVeryClose( word.string, presentword.string );\n      }))\n      {\n        arr.push( word );\n      }\n    }\n    // retain only entries with more than one member in the list\n    var mpduplicates = {} as {[key : string] :  { [key : number] : Array<IMatch.IWord> } };\n    Object.keys( mp ).forEach( (key) => {\n      var entry = mp[key];\n      Object.keys( entry ).forEach( (keybitindex) => {\n        if ( entry[keybitindex].length > 1)\n        {\n          if (!mpduplicates[key])\n            mpduplicates[key] = {} as { [key : number] : Array<IMatch.IWord> };\n          mpduplicates[key][keybitindex] = entry[keybitindex];\n        }\n      });\n    });\n    return Object.keys( mpduplicates ).every( (key) =>  {\n      return Object.keys( mpduplicates[ key ] ).every( ( bi ) => {\n        var lst = mpduplicates[key][bi];\n        var idxmap = {} as { [akey : number] : Array<IMatch.IWord> };\n        /* ok, do some work ..  */\n        /* for every duplicate we collect an index  idx -> word */\n        for( var alst of lst )\n        {\n          var idx = sentence.indexOf( alst );\n          if ( idx < 0 )\n            throw new Error(\"word must be found in sentence \");\n          idxmap[ idx ] = alst;\n        }\n        /* then we run through all the sentences identifying *identical source words pairs,\n           if we find a  a) distinct sentence with\n                      b) same categories F16/F16\n                  and c) *higher matches* for both , then we discard *this* sentence\n                  */\n        return sentences.every( (othersentence) => {\n          if( othersentence === sentence )\n            return true;\n          if ( isSameCategoryAndHigherMatch( othersentence, idxmap) )\n          {\n            debuglog(\" removing sentence with due to higher match \" +  Sentence.simplifyStringsWithBitIndex(sentence)\n            + \" as \" + Sentence.simplifyStringsWithBitIndex( othersentence ) + \" appears better \");\n            return false;\n          }\n          return true;\n        });\n      })\n    });\n  });\n  debuglog(\" here res \" + !res + \" \" +  Sentence.simplifyStringsWithBitIndex(sentence) );\n  return !res;\n}\n\n\n/*\n * Return true if the identical source word is interpreted\n * (within the same domain and the same wordtype)\n * as a differnent  (e.g. element numb is one interpreted as 'CAT' element name, once as CAT 'element number' in\n * same domain IUPAC elements)\n *\n * - exact match\n * - stemming by removing/appending traling s\n * - closeness\n *\n * @param sentence\n */\nexport function isDistinctInterpretationForSameOLD(sentence : IMatch.ISentence) : boolean {\n  var mp = {} as {[key : string] : IMatch.IWord};\n  var res = sentence.every((word, index) => {\n    var seen = mp[word.string];\n    if(!seen)\n    { // exact match\n      /*if( word.string.length > 3 && word.string.charAt(word.string.length - 1).toLowerCase() == 's')\n      {\n\n      }\n      */\n    }\n    if(!seen) {\n      mp[word.string] = word;\n      return true;\n    }\n    if(!seen.rule || !word.rule) {\n      return true;\n    }\n    if(seen.rule.bitindex === word.rule.bitindex\n      && seen.rule.matchedString !== word.rule.matchedString ){\n      //  console.log(\"skipping this\" + JSON.stringify(sentence,undefined,2));\n        return false;\n    }\n    return true;\n  });\n  return res;\n}\n\nexport function filterNonSameInterpretations(aSentences :  IMatch.IProcessedSentences ) : IMatch.IProcessedSentences {\n  var discardIndex = [] as Array<number>;\n  var res = (Object as any).assign( {}, aSentences );\n  res.sentences = aSentences.sentences.filter((sentence,index) => {\n    if(!isDistinctInterpretationForSame(sentence)) {\n      discardIndex.push(index);\n      return false;\n    }\n    return true;\n  });\n  if(discardIndex.length) {\n    res.errors = aSentences.errors.filter( (error,index) => {\n      if(discardIndex.indexOf(index) >= 0) {\n        return false;\n      }\n      return true;\n    });\n  }\n  return res;\n}\n\nfunction isNullOrEmptyDictionary(obj) {\n  return (obj === undefined) || (Object.keys(obj).length === 0);\n}\n\n\nexport function filterBadOperatorArgs(aSentences :  IMatch.IProcessedSentences, operators : IFModel.IOperators ) : IMatch.IProcessedSentences {\n  if ( isNullOrEmptyDictionary(operators) )\n    return aSentences;\n  var discardIndex = [] as Array<number>;\n  var res = (Object as any).assign( {}, aSentences );\n  res.sentences = aSentences.sentences.filter((sentence,index) => {\n    if(isBadOperatorArgs(sentence, operators)) {\n      discardIndex.push(index);\n      return false;\n    }\n    return true;\n  });\n  if(discardIndex.length) {\n    res.errors = aSentences.errors.filter( (error,index) => {\n      if(discardIndex.indexOf(index) >= 0) {\n        return false;\n      }\n      return true;\n    });\n  }\n  return res;\n}\n\n\nexport function filterReverseNonSameInterpretations(aSentences :  IMatch.IProcessedSentences ) : IMatch.IProcessedSentences {\n  var discardIndex = [] as Array<number>;\n  var res = (Object as any).assign( {}, aSentences );\n  res.sentences = aSentences.sentences.filter((sentence,index) => {\n    if(isNonOptimalDistinctSourceForSame(sentence, aSentences.sentences)) {\n      discardIndex.push(index);\n      return false;\n    }\n    return true;\n  });\n  if(discardIndex.length) {\n    res.errors = aSentences.errors.filter( (error,index) => {\n      if(discardIndex.indexOf(index) >= 0) {\n        return false;\n      }\n      return true;\n    });\n  }\n  return res;\n}\n\nexport function processString2(query: string, rules: IFModel.SplitRules,\n words: { [key: string]: Array<IMatch.ICategorizedString> },\n operators : { [key:string] : IOperator }\n):  IMatch.IProcessedSentences {\n  words = words || {};\n  var tokenStruct = tokenizeString(query, rules, words);\n  debuglog(()=> `tokenized:\\n` + tokenStruct.categorizedWords.map( s => Sentence.simplifyStringsWithBitIndex(s).join(\"\\n\") ).join(\"\\n\"));\n  evaluateRangeRulesToPosition(tokenStruct.tokens, tokenStruct.fusable,\n    tokenStruct.categorizedWords);\n  debuglogV(()=>\"After matched \" + JSON.stringify(tokenStruct.categorizedWords));\n  var aSentences = expandTokenMatchesToSentences2(tokenStruct.tokens, tokenStruct.categorizedWords);\n  debuglog(() => \"after expand \" + aSentences.sentences.map(function (oSentence) {\n    return Sentence.rankingProduct(oSentence) + \":\\n\" + Sentence.dumpNiceBitIndexed(oSentence); //JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  aSentences = filterBadOperatorArgs(aSentences, operators)\n  aSentences = filterNonSameInterpretations(aSentences);\n\n  aSentences = filterReverseNonSameInterpretations(aSentences);\n\n  aSentences.sentences = WordMatch.reinForce(aSentences.sentences);\n  debuglogV(()=> \"after reinforce\\n\" + aSentences.sentences.map(function (oSentence) {\n      return Sentence.rankingProduct(oSentence) + \":\\n\" + JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  debuglog(() => \"after reinforce\" + aSentences.sentences.map(function (oSentence) {\n    return Sentence.rankingProduct(oSentence) + \":\\n\" + Sentence.dumpNiceBitIndexed(oSentence); //JSON.stringify(oSentence);\n    }).join(\"\\n\"));\n  return aSentences;\n}\n\n\n"],"sourceRoot":"ABC"}