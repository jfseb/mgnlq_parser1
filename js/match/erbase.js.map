{"version":3,"sources":["/projects/nodejs/botbuilder/mgnlq_parser1/src//projects/nodejs/botbuilder/mgnlq_parser1/src/../src/match/erbase.ts"],"names":[],"mappings":";AAAA;;;;;;;;GAQG;;;AAGH,2CAA2C;AAC3C,+CAA+C;AAE/C,gCAAgC;AAIhC,IAAI,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;AAC/B,IAAI,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC;AACjC,IAAI,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;AAE5B,6CAAqD;AACrD,qCAAqC;AAErC,MAAM,SAAS,GAAQ,MAAM,CAAC;AAE9B,SAAgB,SAAS,CAAC,CAAC;IACzB,QAAQ,GAAG,CAAC,CAAC;IACb,SAAS,GAAG,CAAC,CAAC;IACd,OAAO,GAAG,CAAC,CAAC;AACd,CAAC;AAJD,8BAIC;AAGD,oCAAoC;AAGpC,6CAAiD;AAKjD,uCAAuC;AAEvC,+BAA+B;AAiC/B;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,SAAgB,cAAc,CAAC,OAAe,EAAE,KAAwB,EACtE,KAA0D;IAE1D,IAAI,GAAG,GAAG,CAAC,CAAC;IACZ,IAAI,GAAG,GAAG,CAAC,CAAC;IACZ,IAAI,MAAM,GAAG,uBAAS,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;IAC/C,IAAI,QAAQ,CAAC,OAAO,EAAE;QACpB,QAAQ,CAAC,gBAAgB,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;KACrD;IACD,iCAAiC;IACjC,KAAK,GAAG,KAAK,IAAI,EAAE,CAAC;IACpB,OAAO,CAAC,yBAAyB,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC;IAC/D,IAAI,GAAG,GAAG,EAAyC,CAAC;IACpD,IAAI,MAAM,GAAG,EAAE,CAAC;IAChB,IAAI,mBAAmB,GAAG,EAAyC,CAAC;IACpE,IAAI,aAAa,GAAG,KAAK,CAAC;IAC1B,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,KAAK,EAAE,KAAK;QAC1C,IAAI,MAAM,GAAG,SAAS,CAAC,0BAA0B,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;QACxF;;;UAGE;QACF,aAAa,GAAG,aAAa,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACvE,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,gBAAgB,KAAK,IAAI,KAAK,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;YAC5F,CAAC,CAAC,GAAG,CAAC,CAAC;QACR,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,gBAAgB,KAAK,IAAI,KAAK,MAAM;YACjE,MAAM,CAAC,GAAG,CAAE,CAAC,EAAE,EAAC,GAAG,EAAE,EAAE,GAAG,OAAO,IAAI,GAAG,KAAK,EAAE,CAAC,IAAI,CAAC,aAAa,IAAI,EAAE,CAAC,IAAI,CAAC,QAAQ,KAAK,EAAE,CAAC,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,GAAG,CAAA,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC/I,CAAC,CAAC,GAAG,CAAC,CAAC;QACR,mBAAmB,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC;QACpC,GAAG,GAAG,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC;QAC1B,GAAG,GAAG,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC;IAC5B,CAAC,CAAC,CAAC;IACH,sCAAsC;IACtC,QAAQ,CAAC,aAAa,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,WAAW,GAAG,GAAG,GAAG,QAAQ,GAAG,GAAG,CAAC,CAAC;IACpF,IAAI,QAAQ,CAAC,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE;QAC5C,QAAQ,CAAC,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;KACjE;IACD,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,oBAAoB,IAAI,CAAC,SAAS,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAC9F,IAAI,aAAa,EAAE;QACjB,4BAA4B,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,OAAO,EAAE,mBAAmB,CAAC,CAAC;KAClF;IACD,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,oBAAoB,IAAI,CAAC,SAAS,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAC9F,OAAO,CAAC,aAAa,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,KAAK,GAAG,GAAG,CAAC,MAAM,GAAG,WAAW,GAAG,GAAG,GAAG,QAAQ,GAAG,GAAG,GAAG,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;IAC3J,OAAO;QACL,OAAO,EAAE,MAAM,CAAC,OAAO;QACvB,MAAM,EAAE,MAAM,CAAC,MAAM;QACrB,gBAAgB,EAAE,mBAAmB;KACtC,CAAA;AACH,CAAC;AAhDD,wCAgDC;AAED,SAAgB,SAAS,CAAC,OAAwC,EAAE,GAAqC;IACvG,IAAG,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,KAAK,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC;WACvD,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,KAAK,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC;WAC7C,CAAC,OAAO,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC;WAC7B,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,KAAK,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE;QAC/C,OAAO,CAAC,CAAC;KACZ;IACD,IAAG,OAAO,CAAC,QAAQ,GAAG,GAAG,CAAC,QAAQ,EAAE;QAClC,OAAO,CAAC,CAAC,CAAC;KACX;IACD,OAAO,CAAC,CAAC,CAAC;AACZ,CAAC;AAXD,8BAWC;AAED,SAAgB,mBAAmB,CAAC,MAA0C,EAAE,GAAqC;IACnH,IAAI,WAAW,GAAG,CAAC,CAAC,CAAC;IACrB,IAAI,YAAY,GAAG,MAAM,CAAC,KAAK,CAAE,CAAC,OAAO,EAAC,KAAK,EAAE,EAAE;QACjD,IAAI,CAAC,GAAG,SAAS,CAAC,OAAO,EAAC,GAAG,CAAC,CAAC;QAC/B,IAAI,CAAC,GAAG,CAAC,EAAE;YACT,mGAAmG;YACnG,MAAM,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC;YACpB,OAAO,KAAK,CAAC;SACd;aAAM,IAAG,CAAC,GAAG,CAAC,EAAE;YACf,kCAAkC;YAClC,OAAO,KAAK,CAAC;SACd;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;IACH,IAAG,YAAY,EAAE;QACf,qBAAqB;QACrB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;KAClB;AACH,CAAC;AAlBD,kDAkBC;AAED,SAAgB,4BAA4B,CAAC,MAAgB,EAAE,OAAkB,EAAE,gBAAqD;IACtI,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,kCAAkC,GAAG,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAC3G,gBAAgB,CAAC,OAAO,CAAC,UAAU,QAAQ,EAAE,KAAK;QAChD,QAAQ,CAAC,OAAO,CAAC,UAAU,IAAI;YAC7B,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;gBACnB,2GAA2G;gBAC3G,IAAI,WAAW,GAAG,uBAAS,CAAC,4BAA4B,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;gBAC1F,6EAA6E;gBAC7E,IAAI,WAAW,IAAI,CAAC,EAAE;oBACpB,IAAI,YAAY,GAAG,uBAAS,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;oBAC3E,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,UAAU,YAAY,cAAc,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,aAAa,KAAK,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;oBACvJ,IAAI,GAAG,GAAG,SAAS,CAAC,4CAA4C,CAAC,YAAY,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;oBACrG,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;oBACzE,IAAI,GAAG,EAAE;wBACP,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC;wBAC1D,gBAAgB,CAAC,WAAW,CAAC,GAAG,gBAAgB,CAAC,WAAW,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,+BAA+B;wBACvG,QAAQ,CAAC,iBAAiB,WAAW,EAAE,CAAC,CAAC;wBACzC,mBAAmB,CAAC,gBAAgB,CAAC,WAAW,CAAC,EAAC,GAAG,CAAC,CAAC;wBAChE,kGAAkG;qBAC1F;iBACF;aACF;QACH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,2BAA2B;IAC3B,gBAAgB,CAAC,OAAO,CAAC,UAAU,QAAQ,EAAE,KAAK;QAChD,gBAAgB,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACtE,CAAC,CAAC,CAAC;AACL,CAAC;AA5BD,oEA4BC;AAKD,MAAM,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC;AAK9B,SAAS,cAAc,CAAC,CAAC;IACvB,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;QAC7B,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KACpB;IACD,OAAO,CAAC,CAAC;AACX,CAAC;AAGD,yCAAyC;AACzC,0CAA0C;AAC1C,WAAW;AAEX,SAAgB,SAAS,CAAC,GAAe,EAAE,KAAa;IACtD,IAAI,YAAY,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,GAAG,EAAE,EAAE,CAAC,IAAI,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACjF,OAAO,YAAY,GAAG,KAAK,CAAC;AAC9B,CAAC;AAHD,8BAGC;AAED;;;;;;;GAOG;AACH,SAAgB,6BAA6B,CAAC,MAAgB,EAAE,YAA+B;IAC7F,OAAO,8BAA8B,CAAE,MAAM,EAAE,YAAY,CAAC,CAAC;AAC/D,CAAC;AAFD,sEAEC;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAkEC;AAEF,iBAAiB;AACjB,SAAgB,WAAW,CAAC,KAAc;IACxC,OAAO,EAAE,MAAM,EAAE,KAAK;QACpB,aAAa,EAAE,KAAK;QACpB,QAAQ,EAAE,KAAK;QACf,IAAI,EACH,EAAE,QAAQ,EAAE,KAAK;YACf,IAAI,EAAE,CAAC;YACP,IAAI,EAAE,KAAK;YACX,aAAa,EAAE,KAAK,CAAC,WAAW,EAAE;YAClC,aAAa,EAAE,KAAK;YACpB,SAAS,EAAE,IAAI;YACf,QAAQ,EAAE,IAAI;YACd,cAAc,EAAE,IAAI;YACpB,QAAQ,EAAE,GAAG;YACb,QAAQ,EAAE,GAAG,EAAE;QAClB,QAAQ,EAAE,GAAG;KACd,CAAC;AACJ,CAAC;AAjBD,kCAiBC;AAED,SAAgB,mBAAmB,CAAC,GAAS,EAAE,UAAmB;IAChE,IAAG,UAAU,KAAK,CAAC,EAAE;QACnB,OAAO,KAAK,CAAC;KACd;IACD,IAAG,GAAG,CAAC,GAAG,CAAC,MAAM,GAAC,CAAC,CAAC,CAAC,IAAI,IAAI,GAAG,CAAC,GAAG,CAAC,MAAM,GAAC,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,KAAK,GAAG,EAAE;QACpE,IAAK,qBAAM,CAAC,0BAA0B,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,GAAC,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EACzF;YACE,QAAQ,CAAC,GAAE,EAAE,CAAA,sBAAsB,GAAG,IAAI,CAAC,SAAS,CAAE,GAAG,CAAC,GAAG,CAAC,MAAM,GAAC,CAAC,CAAC,CAAE,CAAC,CAAC;YAC3E,OAAO,IAAI,CAAC;SACb;KACF;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAZD,kDAYC;AACD;;;;;;;GAOG;AACH,SAAgB,8BAA8B,CAAC,MAAgB,EAAE,YAA+B;IAC9F,IAAI,CAAC,GAAG,EAAE,CAAC;IACX,IAAI,WAAW,GAAG,EAAE,CAAC;IACrB,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IACjE,YAAY,CAAC,OAAO,CAAC,UAAU,YAAY,EAAE,SAAiB;QAC5D,WAAW,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;QAC5B,YAAY,CAAC,OAAO,CAAC,UAAU,YAAY,EAAE,gBAAwB;YACnE,WAAW,CAAC,SAAS,CAAC,CAAC,gBAAgB,CAAC,GAAG,YAAY,CAAC;QAC1D,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAChE,IAAI,MAAM,GAAG;QACX,MAAM,EAAE,EAAE;QACV,MAAM,EAAE,MAAM;QACd,SAAS,EAAE,EAAE;KACgB,CAAC;IAChC,IAAI,KAAK,GAAG,EAAE,CAAC;IACf,IAAI,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC;IACf,kBAAkB;IAClB,IAAI,IAAI,GAAG,EAAE,CAAC;IACd,KAAK,IAAI,UAAU,GAAG,CAAC,EAAE,UAAU,GAAG,YAAY,CAAC,MAAM,EAAE,EAAE,UAAU,EAAE,EAAE,gBAAgB;QACzF,yEAAyE;QACzE,IAAI,QAAQ,GAAG,EAAE,CAAC;QAClB,oGAAoG;QACpG,+BAA+B;QAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YACnC,IAAI,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,EAAE;gBACjC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;aACvB;iBAAM,IAAI,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC,EAAC,UAAU,CAAC,EAAE;gBACjD,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAC7C,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;aACvB;SACF;QACD,uFAAuF;QACvF,qGAAqG;QACrG;;;;;;UAME;QACF,IAAI,UAAU,GAAG,YAAY,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC;QACjD,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,UAAU,KAAK,CAAC,EAAE;YAC7C,2CAA2C;YAC3C,mCAAmC;YACnC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,uBAAuB,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC,CAAC;YACxE,GAAG;SACJ;QACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,EAAE,CAAC,EAAE,EAAE,sCAAsC;YAC3E,8CAA8C;YAC9C,IAAI,KAAK,GAAG,EAAE,CAAC,CAAC,+CAA+C;YAC/D,sDAAsD;YACtD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;gBACnC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC,EAAC,UAAU,CAAC,EAAE;oBAC7E,0DAA0D;oBAC1D,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,6BAA6B;oBACzD,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,cAAc,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oBAClE,6DAA6D;oBAC7D,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,CAC1B,KAAK,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,uBAAuB;oBAC9D,uEAAuE;iBACxE;aACF;YACD,kFAAkF;YAClF,+EAA+E;YAC/E,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAClC,mFAAmF;SACpF,CAAC,SAAS;QACX,uEAAuE;QACvE,GAAG,GAAG,QAAQ,CAAC;KAChB;IACD,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,oBAAoB,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAC5G,GAAG,GAAG,GAAG,CAAC,MAAM,CAAE,CAAC,QAAQ,EAAC,KAAK,EAAE,EAAE;QACnC,IAAI,IAAI,GAAG,UAAU,CAAC;QACtB,uCAAuC;QACvC,OAAO,QAAQ,CAAC,KAAK,CAAE,CAAC,IAAI,EAAC,MAAM,EAAE,EAAE;YACrC,IAAI,CAAC,IAAI,CAAC,IAAI;gBACZ,OAAO,IAAI,CAAC;YACd,IAAI,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;YACzC,oHAAoH;YACpH,OAAO,IAAI,KAAK,CAAC,CAAA;QAAC,CAAC,CAAE,CAAA;IACzB,CAAC,CAAC,CAAC;IACH,MAAM,CAAC,SAAS,GAAG,GAAG,CAAC;IACvB,OAAO,MAAM,CAAC;AAChB,CAAC;AArFD,wEAqFC;AAID,SAAgB,aAAa,CAAC,KAAa,EAAE,KAAyB,EACrE,KAA0D,EAC1D,SAAwC;IAEvC,KAAK,GAAG,KAAK,IAAI,EAAE,CAAC;IACpB,SAAS,GAAG,SAAS,IAAI,EAAE,CAAC;IAC5B,kCAAkC;IAClC,OAAO,cAAc,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC;AACxD,CAAC;AARD,sCAQC;AACC;;;;;;;;;;;;;;;;;;;;EAoBE;AAGJ,SAAgB,mBAAmB,CAAE,EAAqC,EAAE,IAAmB;IAE7F,IAAI,GAAG,GAAG,EAAyB,CAAC;IACpC,KAAK,IAAI,GAAG,IAAI,EAAE,EAClB;QACE,IAAK,GAAG,IAAI,IAAI,CAAC,MAAM,EACvB;YACE,GAAG,CAAC,IAAI,CAAE,EAAE,CAAE,GAAG,CAAE,CAAC,CAAC;SACtB;aACI,IAAK,YAAY,CAAC,YAAY,CAAC,yBAAyB,CAAE,GAAG,EAAE,IAAI,CAAC,MAAM,CAAE,EACjF;YACE,GAAG,CAAC,IAAI,CAAE,EAAE,CAAC,GAAG,CAAC,CAAE,CAAC;SACrB;KACF;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAfD,kDAeC;AAED;;;;;;;;;;;;;;;;;;;;;;;EAuBE;AACF,SAAgB,+BAA+B,CAAC,QAA2B;IACzE,IAAI,EAAE,GAAG,EAAqC,CAAC;IAC/C,IAAI,GAAG,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;QACvC,IAAI,KAAK,GAAG,mBAAmB,CAAE,EAAE,EAAE,IAAI,CAAE,CAAC;QAC5C,QAAQ,CAAC,2BAA2B,GAAG,IAAI,CAAC,MAAM,GAAG,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;QAChG,KAAK,IAAI,IAAI,IAAI,KAAK,EACtB;YACE,6BAA6B;YAC7B;;;eAGG;YACH,IAAG,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;gBAC3B,cAAc;aACf;iBACI,IAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,IAAI,CAAC,QAAQ;mBAC5C,IAAI,CAAC,IAAI,CAAC,aAAa,KAAK,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;gBACtD,QAAQ,CAAC,eAAe,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAC,SAAS,EAAC,CAAC,CAAC,CAAC,CAAC;gBACjE,OAAO,KAAK,CAAC;aAChB;SACF;QACD,IAAG,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,EACnB;YACE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;YACvB,OAAO,IAAI,CAAC;SACb;QACD,OAAO,IAAI,CAAC;IACf,CAAC,CAAC,CAAC;IACH,OAAO,GAAG,CAAC;AACZ,CAAC;AA7BD,0EA6BC;AAED,SAAgB,4BAA4B,CAAC,QAA2B,EAAG,MAAkD;IAC3H,IAAI,WAAW,GAAG,EAA+C,CAAC;IAClE,IAAI,GAAG,GAAG,CAAC,CAAC;IACZ,IAAI,KAAK,GAAE,GAAG,CAAC;IACf,IAAI,IAAI,GAAG,GAAG,CAAC;IACf,MAAM,CAAC,IAAI,CAAE,MAAM,CAAE,CAAC,OAAO,CAAE,CAAC,MAAM,EAAE,EAAE;QACxC,IAAI,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;QACzB,IAAI,GAAG,GAAG,QAAQ,CAAE,MAAM,CAAE,CAAC;QAC7B,IAAK,QAAQ,CAAC,MAAM,GAAG,GAAG,EAC1B;YACE,IAAI,IAAI,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC;YACzB,IAAI,IAAI,CAAC,MAAM,KAAK,GAAG,CAAC,MAAM;mBACzB,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,GAAG,CAAC,IAAI,CAAC,QAAQ;mBACxC,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,GAAG,CAAC,IAAI,CAAC,QAAQ;mBACxC,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,GAAG,CAAC,IAAI,CAAC,QAAQ,EAC7C;gBACE,EAAE,GAAG,CAAC;gBACN,KAAK,GAAG,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC;gBAC9B,IAAI,GAAG,IAAI,GAAG,GAAG,CAAC,QAAQ,CAAC;aAC5B;SACF;IACH,CAAC,CAAC,CAAC;IACH,IAAK,GAAG,KAAK,MAAM,CAAC,IAAI,CAAE,MAAM,CAAE,CAAC,MAAM,IAAI,KAAK,GAAG,IAAI,EACzD;QACE,OAAO,IAAI,CAAC;KACb;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AA3BD,oEA2BC;AAED,SAAS,WAAW,CAAE,MAAe,EAAE,KAAc,EAAE,QAA0B,EAAE,KAAc;IAE/F,mDAAmD;IACnD,mDAAmD;IACnD,IAAI,GAAG,GAAG,MAAM,GAAG,CAAC,CAAC;IACrB,IAAK,GAAG,IAAI,KAAK;QACd,GAAG,GAAG,CAAC,CAAC,CAAC;IACZ,GAAG,IAAI,KAAK,CAAC;IACb,IAAI,GAAG,GAAG,GAAG,GAAG,KAAK,CAAC;IACtB,OAAO,QAAQ,CAAC,GAAG,CAAC,CAAC;AACvB,CAAC;AAED,SAAgB,iBAAiB,CAAC,QAA2B,EAAE,SAA4B;IACzF,IAAI,uBAAuB,CAAC,SAAS,CAAC;QACpC,OAAO,KAAK,CAAC;IACf,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAE,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;QACtC,IAAK,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,qBAAM,CAAC,QAAQ,CAAC,QAAQ;YAChE,OAAO,IAAI,CAAC;QACd,IAAI,EAAE,GAAE,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QAC3C,IAAI,CAAC,EAAE;YACL,OAAO,IAAI,CAAC;QACd,IAAI,WAAW,GAAG,EAAE,CAAC,WAAW,IAAI,CAAC,CAAC;QACtC,IAAI,CAAC,EAAE,CAAC,KAAK;YACX,OAAO,IAAI,CAAC;QACd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,EAClC;YACE,IAAI,OAAO,GAAG,WAAW,CAAE,CAAC,EAAE,WAAW,EAAG,QAAQ,EAAE,KAAK,CAAE,CAAC;YAC9D,IAAI,CAAC,OAAO;gBACV,OAAO,KAAK,CAAC;YACf,IAAI,OAAO,GAAG,EAAE,CAAC,WAAW,CAAE,CAAC,GAAG,CAAC,CAAC,CAAC;YACrC,IAAI,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAG,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,kBAAkB,CAAE,CAAC,CAAE,CAAC,CAAC;YAC3E,IAAK,QAAQ,CAAC,OAAO,CAAE,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAE,GAAG,CAAC,EAClD;gBACE,OAAO,CAAC,GAAG,CAAE,wBAAwB,GAAG,EAAE,CAAC,QAAQ,GAAG,QAAQ,GAAG,CAAC,GAAG,WAAW,GAAG,IAAI,CAAC,SAAS,CAAE,QAAQ,CAAE,GAAG,OAAO,GAAI,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAClJ,QAAQ,CAAE,GAAE,EAAE,GAAG,OAAO,wBAAwB,GAAG,EAAE,CAAC,QAAQ,GAAG,QAAQ,GAAG,CAAC,GAAG,WAAW,GAAG,IAAI,CAAC,SAAS,CAAE,QAAQ,CAAE,GAAG,OAAO,GAAI,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA,CAAC,CAAC,CAAC;gBAC/J,OAAO,KAAK,CAAC;aACd;SACF;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;AACL,CAAC;AA5BD,8CA4BC;AAGD;;;;;;;;;;;;;;;;;;;;;;;;;;EA0BE;AACF,SAAgB,iCAAiC,CAAC,QAA2B,EAAE,SAAmC;IAChH,IAAI,EAAE,GAAG,EAAmE,CAAC;IAC7E,4CAA4C;IAC5C,IAAI,GAAG,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,EAAE;QAChC,IAAK,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,QAAQ,CAAC,YAAY;eAC5C,CAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,qBAAM,CAAC,QAAQ,CAAC,IAAI;mBAC3C,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,qBAAM,CAAC,QAAQ,CAAC,QAAQ,CAAE,EACzD;YACE,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAE;gBAC/B,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,EAA8C,CAAC;YAC/E,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;gBAClD,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,EAA0B,CAAC;YAC/E,IAAI,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC1D,IAAI,GAAG,CAAC,MAAM,IAAI,CAAC,EACnB;gBACE,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aAChB;YACD,IAAK,CAAC,GAAG,CAAC,KAAK,CAAE,CAAC,WAAW,EAAE,EAAE;gBAC/B,OAAO,YAAY,CAAC,YAAY,CAAC,yBAAyB,CAAE,IAAI,CAAC,MAAM,EAAE,WAAW,CAAC,MAAM,CAAE,CAAC;YAChG,CAAC,CAAC,EACF;gBACE,GAAG,CAAC,IAAI,CAAE,IAAI,CAAE,CAAC;aAClB;SACF;QACD,4DAA4D;QAC5D,IAAI,YAAY,GAAG,EAAmE,CAAC;QACvF,MAAM,CAAC,IAAI,CAAE,EAAE,CAAE,CAAC,OAAO,CAAE,CAAC,GAAG,EAAE,EAAE;YACjC,IAAI,KAAK,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC;YACpB,MAAM,CAAC,IAAI,CAAE,KAAK,CAAE,CAAC,OAAO,CAAE,CAAC,WAAW,EAAE,EAAE;gBAC5C,IAAK,KAAK,CAAC,WAAW,CAAC,CAAC,MAAM,GAAG,CAAC,EAClC;oBACE,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC;wBACpB,YAAY,CAAC,GAAG,CAAC,GAAG,EAA8C,CAAC;oBACrE,YAAY,CAAC,GAAG,CAAC,CAAC,WAAW,CAAC,GAAG,KAAK,CAAC,WAAW,CAAC,CAAC;iBACrD;YACH,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QACH,OAAO,MAAM,CAAC,IAAI,CAAE,YAAY,CAAE,CAAC,KAAK,CAAE,CAAC,GAAG,EAAE,EAAE;YAChD,OAAO,MAAM,CAAC,IAAI,CAAE,YAAY,CAAE,GAAG,CAAE,CAAE,CAAC,KAAK,CAAE,CAAE,EAAE,EAAG,EAAE;gBACxD,IAAI,GAAG,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;gBAChC,IAAI,MAAM,GAAG,EAA+C,CAAC;gBAC7D,0BAA0B;gBAC1B,0DAA0D;gBAC1D,KAAK,IAAI,IAAI,IAAI,GAAG,EACpB;oBACE,IAAI,GAAG,GAAG,QAAQ,CAAC,OAAO,CAAE,IAAI,CAAE,CAAC;oBACnC,IAAK,GAAG,GAAG,CAAC;wBACV,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;oBACrD,MAAM,CAAE,GAAG,CAAE,GAAG,IAAI,CAAC;iBACtB;gBACD;;;;4BAIY;gBACZ,OAAO,SAAS,CAAC,KAAK,CAAE,CAAC,aAAa,EAAE,EAAE;oBACxC,IAAI,aAAa,KAAK,QAAQ;wBAC5B,OAAO,IAAI,CAAC;oBACd,IAAK,4BAA4B,CAAE,aAAa,EAAE,MAAM,CAAC,EACzD;wBACE,QAAQ,CAAC,8CAA8C,GAAI,QAAQ,CAAC,2BAA2B,CAAC,QAAQ,CAAC;8BACvG,MAAM,GAAG,QAAQ,CAAC,2BAA2B,CAAE,aAAa,CAAE,GAAG,kBAAkB,CAAC,CAAC;wBACvF,OAAO,KAAK,CAAC;qBACd;oBACD,OAAO,IAAI,CAAC;gBACd,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAA;QACJ,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,QAAQ,CAAC,YAAY,GAAG,CAAC,GAAG,GAAG,GAAG,GAAI,QAAQ,CAAC,2BAA2B,CAAC,QAAQ,CAAC,CAAE,CAAC;IACvF,OAAO,CAAC,GAAG,CAAC;AACd,CAAC;AAvED,8EAuEC;AAGD;;;;;;;;;;;GAWG;AACH,SAAgB,kCAAkC,CAAC,QAA2B;IAC5E,IAAI,EAAE,GAAG,EAAqC,CAAC;IAC/C,IAAI,GAAG,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;QACvC,IAAI,IAAI,GAAG,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC3B,IAAG,CAAC,IAAI,EACR,EAAE,cAAc;YACd;;;;cAIE;SACH;QACD,IAAG,CAAC,IAAI,EAAE;YACR,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;YACvB,OAAO,IAAI,CAAC;SACb;QACD,IAAG,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;YAC3B,OAAO,IAAI,CAAC;SACb;QACD,IAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,IAAI,CAAC,QAAQ;eACvC,IAAI,CAAC,IAAI,CAAC,aAAa,KAAK,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;YACxD,wEAAwE;YACtE,OAAO,KAAK,CAAC;SAChB;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;IACH,OAAO,GAAG,CAAC;AACb,CAAC;AA3BD,gFA2BC;AAED,SAAgB,4BAA4B,CAAC,UAAwC;IACnF,IAAI,YAAY,GAAG,EAAmB,CAAC;IACvC,IAAI,GAAG,GAAI,MAAc,CAAC,MAAM,CAAE,EAAE,EAAE,UAAU,CAAE,CAAC;IACnD,GAAG,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAC,KAAK,EAAE,EAAE;QAC7D,IAAG,CAAC,+BAA+B,CAAC,QAAQ,CAAC,EAAE;YAC7C,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACzB,OAAO,KAAK,CAAC;SACd;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;IACH,IAAG,YAAY,CAAC,MAAM,EAAE;QACtB,GAAG,CAAC,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,MAAM,CAAE,CAAC,KAAK,EAAC,KAAK,EAAE,EAAE;YACrD,IAAG,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;gBACnC,OAAO,KAAK,CAAC;aACd;YACD,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;KACJ;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAnBD,oEAmBC;AAED,SAAS,uBAAuB,CAAC,GAAG;IAClC,OAAO,CAAC,GAAG,KAAK,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;AAChE,CAAC;AAGD,SAAgB,qBAAqB,CAAC,UAAwC,EAAE,SAA8B;IAC5G,IAAK,uBAAuB,CAAC,SAAS,CAAC;QACrC,OAAO,UAAU,CAAC;IACpB,IAAI,YAAY,GAAG,EAAmB,CAAC;IACvC,IAAI,GAAG,GAAI,MAAc,CAAC,MAAM,CAAE,EAAE,EAAE,UAAU,CAAE,CAAC;IACnD,GAAG,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAC,KAAK,EAAE,EAAE;QAC7D,IAAG,iBAAiB,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAE;YACzC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACzB,OAAO,KAAK,CAAC;SACd;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;IACH,IAAG,YAAY,CAAC,MAAM,EAAE;QACtB,GAAG,CAAC,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,MAAM,CAAE,CAAC,KAAK,EAAC,KAAK,EAAE,EAAE;YACrD,IAAG,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;gBACnC,OAAO,KAAK,CAAC;aACd;YACD,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;KACJ;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AArBD,sDAqBC;AAGD,SAAgB,mCAAmC,CAAC,UAAwC;IAC1F,IAAI,YAAY,GAAG,EAAmB,CAAC;IACvC,IAAI,GAAG,GAAI,MAAc,CAAC,MAAM,CAAE,EAAE,EAAE,UAAU,CAAE,CAAC;IACnD,GAAG,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAC,KAAK,EAAE,EAAE;QAC7D,IAAG,iCAAiC,CAAC,QAAQ,EAAE,UAAU,CAAC,SAAS,CAAC,EAAE;YACpE,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACzB,OAAO,KAAK,CAAC;SACd;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;IACH,IAAG,YAAY,CAAC,MAAM,EAAE;QACtB,GAAG,CAAC,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,MAAM,CAAE,CAAC,KAAK,EAAC,KAAK,EAAE,EAAE;YACrD,IAAG,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;gBACnC,OAAO,KAAK,CAAC;aACd;YACD,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;KACJ;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAnBD,kFAmBC;AAED,SAAgB,cAAc,CAAC,KAAa,EAAE,KAAyB,EACtE,KAA0D,EAC1D,SAAwC;IAEvC,KAAK,GAAG,KAAK,IAAI,EAAE,CAAC;IACpB,IAAI,WAAW,GAAG,cAAc,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;IACtD,QAAQ,CAAC,GAAE,EAAE,CAAC,cAAc,GAAG,WAAW,CAAC,gBAAgB,CAAC,GAAG,CAAE,CAAC,CAAC,EAAE,CAAC,QAAQ,CAAC,2BAA2B,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IACvI,4BAA4B,CAAC,WAAW,CAAC,MAAM,EAAE,WAAW,CAAC,OAAO,EAClE,WAAW,CAAC,gBAAgB,CAAC,CAAC;IAChC,SAAS,CAAC,GAAE,EAAE,CAAA,gBAAgB,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,gBAAgB,CAAC,CAAC,CAAC;IAC/E,IAAI,UAAU,GAAG,8BAA8B,CAAC,WAAW,CAAC,MAAM,EAAE,WAAW,CAAC,gBAAgB,CAAC,CAAC;IAClG,QAAQ,CAAC,GAAG,EAAE,CAAC,eAAe,GAAG,UAAU,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,SAAS;QAC3E,OAAO,QAAQ,CAAC,cAAc,CAAC,SAAS,CAAC,GAAG,KAAK,GAAG,QAAQ,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC,CAAC,4BAA4B;IACxH,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IACjB,UAAU,GAAG,qBAAqB,CAAC,UAAU,EAAE,SAAS,CAAC,CAAA;IACzD,UAAU,GAAG,4BAA4B,CAAC,UAAU,CAAC,CAAC;IAEtD,UAAU,GAAG,mCAAmC,CAAC,UAAU,CAAC,CAAC;IAE7D,UAAU,CAAC,SAAS,GAAG,SAAS,CAAC,SAAS,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;IACjE,SAAS,CAAC,GAAE,EAAE,CAAC,mBAAmB,GAAG,UAAU,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,SAAS;QAC7E,OAAO,QAAQ,CAAC,cAAc,CAAC,SAAS,CAAC,GAAG,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;IAChF,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IACjB,QAAQ,CAAC,GAAG,EAAE,CAAC,iBAAiB,GAAG,UAAU,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,SAAS;QAC7E,OAAO,QAAQ,CAAC,cAAc,CAAC,SAAS,CAAC,GAAG,KAAK,GAAG,QAAQ,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC,CAAC,4BAA4B;IACxH,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IACjB,OAAO,UAAU,CAAC;AACpB,CAAC;AA3BD,wCA2BC","file":"erbase.js","sourcesContent":["/**\r\n *\r\n * @module jfseb.erbase\r\n * @file erbase\r\n * @copyright (c) 2016 Gerd Forstmann\r\n *\r\n * Basic domain based entity recognition\r\n *\r\n */\r\n\r\n\r\nimport * as WordMatch from './inputFilter';\r\nimport * as CharSequence from './charsequence';\r\n\r\nimport * as debug from 'debugf';\r\n\r\n\r\n\r\nvar debuglog = debug('erbase');\r\nvar debuglogV = debug('erVbase');\r\nvar perflog = debug('perf');\r\n\r\nimport { BreakDown as breakdown}  from 'mgnlq_model';\r\nimport * as ERError from './ererror';\r\n\r\nconst AnyObject = <any>Object;\r\n\r\nexport function mockDebug(o) {\r\n  debuglog = o;\r\n  debuglogV = o;\r\n  perflog = o;\r\n}\r\n\r\n\r\nimport * as utils from 'abot_utils';\r\n\r\nimport * as IFErBase from './iferbase';\r\nimport { IFModel  as IMatch}  from 'mgnlq_model';\r\nimport { IFModel  as IFModel}  from 'mgnlq_model';\r\n\r\n\r\n\r\nimport * as Sentence from './sentence';\r\n\r\nimport * as Word from './word';\r\n\r\nimport * as Algol from './algol';\r\nimport { AssertionError } from 'assert';\r\nimport { IOperator } from 'mgnlq_model/js/match/ifmatch';\r\n\r\n\r\n//import * as Match from './match';\r\n\r\n\r\nexport interface ITokenizedString {\r\n  tokens: string[],\r\n  categorizedWords: IMatch.ICategorizedStringRanged[][]\r\n  fusable: boolean[];\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Given a  string, break it down into components,\r\n * [['A', 'B'], ['A B']]\r\n *\r\n * then categorizeWords\r\n * returning\r\n *\r\n * [ [[ { category: 'systemId', word : 'A'},\r\n *      { category: 'otherthing', word : 'A'}\r\n *    ],\r\n *    // result of B\r\n *    [ { category: 'systemId', word : 'B'},\r\n *      { category: 'otherthing', word : 'A'}\r\n *      { category: 'anothertryp', word : 'B'}\r\n *    ]\r\n *   ],\r\n * ]]]\r\n *\r\n *\r\n *\r\n */\r\nexport function tokenizeString(sString: string, rules: IMatch.SplitRules,\r\n  words: { [key: string]: Array<IMatch.ICategorizedString> })\r\n  : ITokenizedString {\r\n  var cnt = 0;\r\n  var fac = 1;\r\n  var tokens = breakdown.tokenizeString(sString);\r\n  if (debuglog.enabled) {\r\n    debuglog(\"here breakdown\" + JSON.stringify(tokens));\r\n  }\r\n  //console.log(JSON.stringify(u));\r\n  words = words || {};\r\n  perflog('this many known words: ' + Object.keys(words).length);\r\n  var res = [] as IMatch.ICategorizedStringRanged[][];\r\n  var cntRec = {};\r\n  var categorizedSentence = [] as IMatch.ICategorizedStringRanged[][];\r\n  var hasRecombined = false;\r\n  tokens.tokens.forEach(function (token, index) {\r\n    var seenIt = WordMatch.categorizeAWordWithOffsets(token, rules, sString, words, cntRec);\r\n    /* cannot have this, or need to add all fragment words \"UI2 Integration\"  if(seenIt.length === 0) {\r\n          return false;\r\n        }\r\n    */\r\n    hasRecombined = hasRecombined || !seenIt.every(res => !res.rule.range);\r\n    debuglogV(debuglogV.enabled ? (` categorized ${token}/${index} to ` + JSON.stringify(seenIt))\r\n     : \"-\");\r\n    debuglog(debuglog.enabled ? (` categorized ${token}/${index} to ` +\r\n    seenIt.map( (it,idx) => { return ` ${idx}  ${it.rule.matchedString}/${it.rule.category}  ${it.rule.wordType}${it.rule.bitindex} ` }).join(\"\\n\"))\r\n     : \"-\");\r\n    categorizedSentence[index] = seenIt;\r\n    cnt = cnt + seenIt.length;\r\n    fac = fac * seenIt.length;\r\n  });\r\n  // have seen the plain categorization,\r\n  debuglog(\" sentences \" + tokens.tokens.length + \" matches \" + cnt + \" fac: \" + fac);\r\n  if (debuglog.enabled && tokens.tokens.length) {\r\n    debuglog(\"first match \" + JSON.stringify(tokens, undefined, 2));\r\n  }\r\n  debuglog(debuglog.enabled ? ` prior RangeRule ${JSON.stringify(categorizedSentence)} ` : '-');\r\n  if (hasRecombined) {\r\n    evaluateRangeRulesToPosition(tokens.tokens, tokens.fusable, categorizedSentence);\r\n  }\r\n  debuglog(debuglog.enabled ? ` after RangeRule ${JSON.stringify(categorizedSentence)} ` : '-');\r\n  perflog(\" sentences \" + tokens.tokens.length + \" / \" + res.length + \" matches \" + cnt + \" fac: \" + fac + \" rec : \" + JSON.stringify(cntRec, undefined, 2));\r\n  return {\r\n    fusable: tokens.fusable,\r\n    tokens: tokens.tokens,\r\n    categorizedWords: categorizedSentence\r\n  }\r\n}\r\n\r\nexport function isSameRes(present: IMatch.ICategorizedStringRanged, res : IMatch.ICategorizedStringRanged)  : number {\r\n  if(!((present.rule.matchedString === res.rule.matchedString)\r\n    && (present.rule.category === res.rule.category)\r\n    && (present.span === res.span)\r\n  && (present.rule.bitindex === res.rule.bitindex))) {\r\n      return 0;\r\n  }\r\n  if(present._ranking < res._ranking) {\r\n    return -1;\r\n  }\r\n  return +1;\r\n}\r\n\r\nexport function mergeIgnoreOrAppend(result : IMatch.ICategorizedStringRanged[], res : IMatch.ICategorizedStringRanged) {\r\n  var insertindex = -1;\r\n  var foundNothing = result.every( (present,index) => {\r\n    var r = isSameRes(present,res);\r\n    if (r < 0) {\r\n      //console.log(\"overwriting worse \\n\" + JSON.stringify(res) + '\\n' + JSON.stringify(present)+ '\\n');\r\n      result[index] = res;\r\n      return false;\r\n    } else if(r > 0) {\r\n      //console.log('skipping present');\r\n      return false;\r\n    }\r\n    return true;\r\n  });\r\n  if(foundNothing) {\r\n    //debulog('pushing');\r\n    result.push(res);\r\n  }\r\n}\r\n\r\nexport function evaluateRangeRulesToPosition(tokens: string[], fusable: boolean[], categorizedWords: IMatch.ICategorizedStringRanged[][]) {\r\n  debuglog(debuglog.enabled ? (\"evaluateRangeRulesToPosition... \" + JSON.stringify(categorizedWords)) : '-');\r\n  categorizedWords.forEach(function (wordlist, index) {\r\n    wordlist.forEach(function (word) {\r\n      if (word.rule.range) {\r\n        //console.log(` got targetindex for RangeRules evaluation : ${targetIndex} ${index} ${fusable.join(\" \")}`);\r\n        var targetIndex = breakdown.isCombinableRangeReturnIndex(word.rule.range, fusable, index);\r\n        //console.log(` got targetindex for RangeRules evaluation : ${targetIndex}`);\r\n        if (targetIndex >= 0) {\r\n          var combinedWord = breakdown.combineTokens(word.rule.range, index, tokens);\r\n          debuglog(debuglog.enabled ? (` test \"${combinedWord}\" against \"${word.rule.range.rule.lowercaseword}\" ${JSON.stringify(word.rule.range.rule)}`) : '-');\r\n          var res = WordMatch.categorizeWordWithOffsetWithRankCutoffSingle(combinedWord, word.rule.range.rule);\r\n          debuglog(debuglog.enabled ? (\" got res : \" + JSON.stringify(res)) : '-');\r\n          if (res) {\r\n            res.span = word.rule.range.high - word.rule.range.low + 1;\r\n            categorizedWords[targetIndex] = categorizedWords[targetIndex].slice(0); // avoid invalidation of seenit\r\n            debuglog(`pushed sth at ${targetIndex}`);\r\n            mergeIgnoreOrAppend(categorizedWords[targetIndex],res);\r\n   //         categorizedWords[targetIndex].push(res); // check that this does not invalidate seenit!\r\n          }\r\n        }\r\n      }\r\n    });\r\n  });\r\n  // filter all range rules !\r\n  categorizedWords.forEach(function (wordlist, index) {\r\n    categorizedWords[index] = wordlist.filter(word => !word.rule.range);\r\n  });\r\n}\r\n\r\n\r\n\r\n\r\nconst clone = utils.cloneDeep;\r\n\r\n\r\n\r\n\r\nfunction copyVecMembers(u) {\r\n  var i = 0;\r\n  for (i = 0; i < u.length; ++i) {\r\n    u[i] = clone(u[i]);\r\n  }\r\n  return u;\r\n}\r\n\r\n\r\n// we can replicate the tail or the head,\r\n// we replicate the tail as it is smaller.\r\n// [a,b,c ]\r\n\r\nexport function isSpanVec(vec: Array<any>, index: number) {\r\n  var effectivelen = vec.reduce((prev, mem) => prev += mem.span ? mem.span : 1, 0);\r\n  return effectivelen > index;\r\n}\r\n\r\n/**\r\n * expand an array [[a1,a2], [b1,b2],[c]]\r\n * into all combinations\r\n *\r\n *  if a1 has a span of three, the variations of the lower layer are skipped\r\n *\r\n * with the special property\r\n */\r\nexport function expandTokenMatchesToSentences(tokens: string[], tokenMatches: Array<Array<any>>): IMatch.IProcessedSentences {\r\n  return expandTokenMatchesToSentences2( tokens, tokenMatches);\r\n}\r\n /*\r\nexport function expandTokenMatchesToSentences(tokens: string[], tokenMatches: Array<Array<any>>): IMatch.IProcessedSentences {\r\n  var a = [];\r\n  var wordMatches = [];\r\n  debuglogV(debuglog.enabled ? JSON.stringify(tokenMatches) : '-');\r\n  tokenMatches.forEach(function (aWordMatches, wordIndex: number) {\r\n    wordMatches[wordIndex] = [];\r\n    aWordMatches.forEach(function (oWordVariant, wordVariantIndex: number) {\r\n      wordMatches[wordIndex][wordVariantIndex] = oWordVariant;\r\n    });\r\n  });\r\n  debuglog(debuglog.enabled ? JSON.stringify(tokenMatches) : '-');\r\n  var result = {\r\n    errors: [],\r\n    tokens: tokens,\r\n    sentences: []\r\n  } as IMatch.IProcessedSentences;\r\n  var nvecs = [];\r\n  var res = [[]];\r\n  // var nvecs = [];\r\n  var rvec = [];\r\n  for (var tokenIndex = 0; tokenIndex < tokenMatches.length; ++tokenIndex) { // wordg index k\r\n    //vecs is the vector of all so far seen variants up to k length.\r\n    var nextBase = [];\r\n    //independent of existence of matches on level k, we retain all vectors which are covered by a span\r\n    // we skip extending them below\r\n    for (var u = 0; u < res.length; ++u) {\r\n      if (isSpanVec(res[u], tokenIndex)) {\r\n        nextBase.push(res[u]);\r\n      }\r\n    }\r\n    var lenMatches = tokenMatches[tokenIndex].length;\r\n    if (nextBase.length === 0 && lenMatches === 0) {\r\n      // the word at index I cannot be understood\r\n      //if (result.errors.length === 0) {\r\n      result.errors.push(ERError.makeError_NO_KNOWN_WORD(tokenIndex, tokens));\r\n      //}\r\n    }\r\n    for (var l = 0; l < lenMatches; ++l) { // for each variant present at index k\r\n      //debuglog(\"vecs now\" + JSON.stringify(vecs));\r\n      var nvecs = []; //vecs.slice(); // copy the vec[i] base vector;\r\n      //debuglog(\"vecs copied now\" + JSON.stringify(nvecs));\r\n      for (var u = 0; u < res.length; ++u) {\r\n        if (!isSpanVec(res[u], tokenIndex)) {\r\n          // for each so far constructed result (of length k) in res\r\n          nvecs.push(res[u].slice()); // make a copy of each vector\r\n          nvecs[nvecs.length - 1] = copyVecMembers(nvecs[nvecs.length - 1]);\r\n          // debuglog(\"copied vecs[\"+ u+\"]\" + JSON.stringify(vecs[u]));\r\n          nvecs[nvecs.length - 1].push(\r\n            clone(tokenMatches[tokenIndex][l])); // push the lth variant\r\n          // debuglog(\"now nvecs \" + nvecs.length + \" \" + JSON.stringify(nvecs));\r\n        }\r\n      }\r\n      //   debuglog(\" at     \" + k + \":\" + l + \" nextbase >\" + JSON.stringify(nextBase))\r\n      //   debuglog(\" append \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nvecs))\r\n      nextBase = nextBase.concat(nvecs);\r\n      //   debuglog(\"  result \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nextBase))\r\n    } //constru\r\n    //  debuglog(\"now at \" + k + \":\" + l + \" >\" + JSON.stringify(nextBase))\r\n    res = nextBase;\r\n  }\r\n  debuglogV(debuglogV.enabled ? (\"APPENDING TO RES2#\" + 0 + \":\" + l + \" >\" + JSON.stringify(nextBase)) : '-');\r\n  result.sentences = res;\r\n  return result;\r\n}\r\n\r\n*/\r\n\r\n// todo: bitindex\r\nexport function makeAnyWord(token : string) {\r\n  return { string: token,\r\n    matchedString: token,\r\n    category: 'any',\r\n    rule:\r\n     { category: 'any',\r\n       type: 0,\r\n       word: token,\r\n       lowercaseword: token.toLowerCase(),\r\n       matchedString: token,\r\n       exactOnly: true,\r\n       bitindex: 4096,\r\n       bitSentenceAnd: 4095,\r\n       wordType: 'A', // IMatch.WORDTYPE.ANY,\r\n       _ranking: 0.9 },\r\n    _ranking: 0.9\r\n  };\r\n}\r\n\r\nexport function isSuccessorOperator(res : any, tokenIndex : number) : boolean {\r\n  if(tokenIndex === 0) {\r\n    return false;\r\n  }\r\n  if(res[res.length-1].rule && res[res.length-1].rule.wordType === 'O') {\r\n    if ( IMatch.aAnySuccessorOperatorNames.indexOf(res[res.length-1].rule.matchedString) >= 0)\r\n    {\r\n      debuglog(()=>' isSuccessorOperator' + JSON.stringify( res[res.length-1] ));\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n/**\r\n * expand an array [[a1,a2], [b1,b2],[c]]\r\n * into all combinations\r\n *\r\n *  if a1 has a span of three, the variations of the lower layer are skipped\r\n *\r\n * with the special property\r\n */\r\nexport function expandTokenMatchesToSentences2(tokens: string[], tokenMatches: Array<Array<any>>): IMatch.IProcessedSentences {\r\n  var a = [];\r\n  var wordMatches = [];\r\n  debuglogV(debuglog.enabled ? JSON.stringify(tokenMatches) : '-');\r\n  tokenMatches.forEach(function (aWordMatches, wordIndex: number) {\r\n    wordMatches[wordIndex] = [];\r\n    aWordMatches.forEach(function (oWordVariant, wordVariantIndex: number) {\r\n      wordMatches[wordIndex][wordVariantIndex] = oWordVariant;\r\n    });\r\n  });\r\n  debuglog(debuglog.enabled ? JSON.stringify(tokenMatches) : '-');\r\n  var result = {\r\n    errors: [],\r\n    tokens: tokens,\r\n    sentences: []\r\n  } as IMatch.IProcessedSentences;\r\n  var nvecs = [];\r\n  var res = [[]];\r\n  // var nvecs = [];\r\n  var rvec = [];\r\n  for (var tokenIndex = 0; tokenIndex < tokenMatches.length; ++tokenIndex) { // wordg index k\r\n    //vecs is the vector of all so far seen variants up to tokenIndex length.\r\n    var nextBase = [];\r\n    // independent of existence of matches on level k, we retain all vectors which are covered by a span\r\n    // we skip extending them below\r\n    for (var u = 0; u < res.length; ++u) {\r\n      if (isSpanVec(res[u], tokenIndex)) {\r\n        nextBase.push(res[u]);\r\n      } else if( isSuccessorOperator(res[u],tokenIndex)) {\r\n        res[u].push(makeAnyWord(tokens[tokenIndex]));\r\n        nextBase.push(res[u]);\r\n      }\r\n    }\r\n    // independent of existence of matches on level tokenIndex, we extend all vectors which\r\n    // are a successor of a binary extending op ( like \"starting with\", \"containing\" with the next token)\r\n    /*   for(var resIndex = 0; resIndex < res.length; ++resIndex) {\r\n      if (isSuccessorOperator(res[resIndex], tokenIndex)) {\r\n        res[resIndex].push(makeAnyWord(tokens[tokenIndex]));\r\n        nextBase.push(res[resIndex]);\r\n      }\r\n    }\r\n    */\r\n    var lenMatches = tokenMatches[tokenIndex].length;\r\n    if (nextBase.length === 0 && lenMatches === 0) {\r\n      // the word at index I cannot be understood\r\n      //if (result.errors.length === 0) {\r\n      result.errors.push(ERError.makeError_NO_KNOWN_WORD(tokenIndex, tokens));\r\n      //}\r\n    }\r\n    for (var l = 0; l < lenMatches; ++l) { // for each variant present at index k\r\n      //debuglog(\"vecs now\" + JSON.stringify(vecs));\r\n      var nvecs = []; //vecs.slice(); // copy the vec[i] base vector;\r\n      //debuglog(\"vecs copied now\" + JSON.stringify(nvecs));\r\n      for (var u = 0; u < res.length; ++u) {\r\n        if (!isSpanVec(res[u], tokenIndex) && !isSuccessorOperator(res[u],tokenIndex)) {\r\n          // for each so far constructed result (of length k) in res\r\n          nvecs.push(res[u].slice()); // make a copy of each vector\r\n          nvecs[nvecs.length - 1] = copyVecMembers(nvecs[nvecs.length - 1]);\r\n          // debuglog(\"copied vecs[\"+ u+\"]\" + JSON.stringify(vecs[u]));\r\n          nvecs[nvecs.length - 1].push(\r\n            clone(tokenMatches[tokenIndex][l])); // push the lth variant\r\n          // debuglog(\"now nvecs \" + nvecs.length + \" \" + JSON.stringify(nvecs));\r\n        }\r\n      }\r\n      //   debuglog(\" at     \" + k + \":\" + l + \" nextbase >\" + JSON.stringify(nextBase))\r\n      //   debuglog(\" append \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nvecs))\r\n      nextBase = nextBase.concat(nvecs);\r\n      //   debuglog(\"  result \" + k + \":\" + l + \" nvecs    >\" + JSON.stringify(nextBase))\r\n    } //constru\r\n    //  debuglog(\"now at \" + k + \":\" + l + \" >\" + JSON.stringify(nextBase))\r\n    res = nextBase;\r\n  }\r\n  debuglogV(debuglogV.enabled ? (\"APPENDING TO RES1#\" + 0 + \":\" + l + \" >\" + JSON.stringify(nextBase)) : '-');\r\n  res = res.filter( (sentence,index) => {\r\n    var full = 0xFFFFFFFF;\r\n    //console.log(`sentence  ${index}  \\n`)\r\n    return sentence.every( (word,index2) => {\r\n      if (!word.rule)\r\n        return true;\r\n      full = (full & word.rule.bitSentenceAnd);\r\n      //console.log(` word  ${index2} ${full} \"${word.matchedString}\" ${word.rule.bitSentenceAnd}  ${tokens[index2]} \\n`);\r\n      return full !== 0 } )\r\n  });\r\n  result.sentences = res;\r\n  return result;\r\n}\r\n\r\n\r\n\r\nexport function processString(query: string, rules: IFModel.SplitRules,\r\n words: { [key: string]: Array<IMatch.ICategorizedString> },\r\n operators : { [key:string] : IOperator }\r\n):  IMatch.IProcessedSentences {\r\n  words = words || {};\r\n  operators = operators || {};\r\n  //if(!process.env.ABOT_NO_TEST1) {\r\n  return processString2(query, rules, words, operators);\r\n}\r\n  /*\r\n  var tokenStruct = tokenizeString(query, rules, words);\r\n  evaluateRangeRulesToPosition(tokenStruct.tokens, tokenStruct.fusable,\r\n    tokenStruct.categorizedWords);\r\n  if (debuglog.enabled) {\r\n    debuglog(\"After matched \" + JSON.stringify(tokenStruct.categorizedWords));\r\n  }\r\n  var aSentences = expandTokenMatchesToSentences(tokenStruct.tokens, tokenStruct.categorizedWords);\r\n  if (debuglog.enabled) {\r\n    debuglog(\"after expand\" + aSentences.sentences.map(function (oSentence) {\r\n    return Sentence.rankingProduct(oSentence) + \":\" + Sentence.dumpNice(oSentence); //JSON.stringify(oSentence);\r\n    }).join(\"\\n\"));\r\n  }\r\n  aSentences.sentences = WordMatch.reinForce(aSentences.sentences);\r\n  if (debuglog.enabled) {\r\n    debuglog(\"after reinforce\" + aSentences.sentences.map(function (oSentence) {\r\n      return Sentence.rankingProduct(oSentence) + \":\" + JSON.stringify(oSentence);\r\n    }).join(\"\\n\"));\r\n  }\r\n  return aSentences;\r\n  */\r\n\r\n\r\nexport function findCloseIdenticals( mp :  {[key : string] : IMatch.IWord}, word : IMatch.IWord ) : Array<IMatch.IWord>\r\n{\r\n  var res = [] as Array<IMatch.IWord>;\r\n  for( var key in mp )\r\n  {\r\n    if ( key == word.string )\r\n    {\r\n      res.push( mp[ key ]);\r\n    }\r\n    else if ( CharSequence.CharSequence.isSameOrPluralOrVeryClose( key, word.string ) )\r\n    {\r\n      res.push( mp[key] );\r\n    }\r\n  }\r\n  return res;\r\n}\r\n\r\n/* Return true if the identical *source word* is interpreted\r\n* (within the same domain and the same wordtype)\r\n* as a differnent  (e.g. element numb is one interpreted as 'CAT' element name, once as CAT 'element number' in\r\n*\r\n* example\r\n* [ 'element names=>element number/category/2 F16',         <<< (1)\r\n*    'element number=>element number/category/2 F16',\r\n*    'element weight=>atomic weight/category/2 F16',\r\n*    'element name=>element name/category/2 F16',           <<< (2)\r\n*    'with=>with/filler I256',\r\n*    'element name=>element name/category/2 F16',           <<< (3)\r\n*   'starting with=>starting with/operator/2 O256',\r\n*    'ABC=>ABC/any A4096' ],\r\n*\r\n* same domain IUPAC elements)\r\n*\r\n*  (1) differs to (2),(3) although the base words are very similar element names, element name, element name respectively\r\n*\r\n* - exact match\r\n* - stemming by removing/appending traling s\r\n* - closeness\r\n*\r\n* @param sentence\r\n*/\r\nexport function isDistinctInterpretationForSame(sentence : IMatch.ISentence) : boolean {\r\n  var mp = {} as {[key : string] : IMatch.IWord};\r\n  var res = sentence.every((word, index) => {\r\n    var seens = findCloseIdenticals( mp, word );\r\n    debuglog(\" investigating seens for \" + word.string + \" \" + JSON.stringify(seens, undefined, 2));\r\n    for( var seen of seens)\r\n    {\r\n      //var seen = mp[word.string];\r\n      /*if(!seen) {\r\n        mp[word.string] = word;\r\n        return true;\r\n      }*/\r\n      if(!seen.rule || !word.rule) {\r\n        //return true;\r\n      }\r\n      else if(seen.rule.bitindex === word.rule.bitindex\r\n        && seen.rule.matchedString !== word.rule.matchedString ){\r\n          debuglog(\"skipping this\" + JSON.stringify(sentence,undefined,2));\r\n          return false;\r\n      }\r\n    }\r\n    if(!mp[word.string])\r\n    {\r\n      mp[word.string] = word;\r\n      return true;\r\n    }\r\n    return true;\r\n });\r\n return res;\r\n}\r\n\r\nexport function isSameCategoryAndHigherMatch(sentence : IMatch.ISentence,  idxmap : { [akey : number] : Array<IMatch.IWord> }) : boolean {\r\n  var idxmapother = {} as { [akey : number] : Array<IMatch.IWord> };\r\n  var cnt = 0;\r\n  var prodo =1.0;\r\n  var prod = 1.0;\r\n  Object.keys( idxmap ).forEach( (idxkey) => {\r\n    var wrd = idxmap[idxkey];\r\n    var idx = parseInt( idxkey );\r\n    if ( sentence.length > idx )\r\n    {\r\n      var wrdo = sentence[idx];\r\n      if( wrdo.string === wrd.string\r\n        && wrdo.rule.bitindex === wrd.rule.bitindex\r\n        && wrdo.rule.wordType === wrd.rule.wordType\r\n        && wrdo.rule.category === wrd.rule.category )\r\n      {\r\n        ++cnt;\r\n        prodo = prodo * wrdo._ranking;\r\n        prod = prod * wrd._ranking;\r\n      }\r\n    }\r\n  });\r\n  if ( cnt === Object.keys( idxmap ).length && prodo > prod )\r\n  {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction get_ith_arg( onepos : number, oppos : number, sentence: IMatch.ISentence, index : number ) : IMatch.IWord\r\n{ ///         oppos=0     oppos=-1     oppos=-2   oppos=1\r\n  // 1 ->  0  -1;           1            2         -2\r\n  // 2  -> 1   1;           2            3         -1\r\n  var pos = onepos - 1;\r\n  if ( pos <= oppos )\r\n     pos = -1;\r\n  pos -= oppos;\r\n  var idx = pos + index;\r\n  return sentence[idx];\r\n}\r\n\r\nexport function isBadOperatorArgs(sentence : IMatch.ISentence, operators: IMatch.IOperators ) : boolean {\r\n  if (isNullOrEmptyDictionary(operators))\r\n    return false;\r\n  return !sentence.every( (word, index) => {\r\n    if(  (word.rule && word.rule.wordType) != IMatch.WORDTYPE.OPERATOR )\r\n      return true;\r\n    var op =operators[word.rule.matchedString];\r\n    if( !op)\r\n      return true;\r\n    var operatorpos = op.operatorpos || 0;\r\n    if (!op.arity)\r\n      return true;\r\n    for( var i = 1; i <= op.arity; ++i)\r\n    {\r\n      var ith_arg = get_ith_arg( i, operatorpos , sentence, index );\r\n      if (!ith_arg)\r\n        return false;\r\n      var argtype = op.argcategory[ i - 1];\r\n      var argtypex = argtype.map(  (x) => Word.WordType.fromCategoryString( x ));\r\n      if ( argtypex.indexOf( ith_arg.rule.wordType ) < 0 )\r\n      {\r\n        console.log( \"discarding due to arg \" + op.operator + \" arg #\" + i + \" expected\" + JSON.stringify( argtypex ) + \" was \"  + ith_arg.rule.wordType);\r\n        debuglog( ()=> { return \"discarding due to arg \" + op.operator + \" arg #\" + i + \" expected\" + JSON.stringify( argtypex ) + \" was \"  + ith_arg.rule.wordType;});\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  });\r\n}\r\n\r\n\r\n/* Return true if the identical *target word* is expressed by different source words\r\n* (within the same domain and the same wordtype)\r\n*\r\n* this is problematic with aliases mapped onto the same target, (eg. where -> with, with -> where )\r\n* so perhaps only for categories and facts?\r\n*\r\n* example <pre>\r\n* [ 'element names=>element number/category/2 C8',         <<< (1a)\r\n*    'element number=>element number/category/2 C8',       <<< (2)\r\n*    'element weight=>atomic weight/category/2 C8',\r\n*    'element name=>element number/category/2 C8',           <<< (1b)\r\n*    'with=>with/filler I256',\r\n*    'element name=>element number/category/2 C8',           <<< (1c)\r\n*    'starting with=>starting with/operator/2 O256',\r\n*    'ABC=>ABC/any A4096' ],\r\n*\r\n* same domain IUPAC elements)\r\n*\r\n*  (1abc) differs from (2),\r\n*  and there is a much better interpretation around\r\n* </pre>\r\n* - exact match\r\n* - stemming by removing/appending traling s\r\n* - closeness\r\n*\r\n* @param sentence\r\n*/\r\nexport function isNonOptimalDistinctSourceForSame(sentence : IMatch.ISentence, sentences : Array<IMatch.ISentence>) : boolean {\r\n  var mp = {} as {[key : string] :  { [key : number] : Array<IMatch.IWord> } };\r\n  // calculate conflicts :    [taget_word -> ]\r\n  var res = sentence.every((word) => {\r\n    if ( word.category === Word.Category.CAT_CATEGORY\r\n      && (  word.rule.wordType === IMatch.WORDTYPE.FACT\r\n         || word.rule.wordType === IMatch.WORDTYPE.CATEGORY ))\r\n    {\r\n      if (!mp[word.rule.matchedString ])\r\n        mp[word.rule.matchedString] = {} as { [key : number] : Array<IMatch.IWord> };\r\n      if( !mp[word.rule.matchedString][word.rule.bitindex])\r\n        mp[word.rule.matchedString][word.rule.bitindex] = [] as  Array<IMatch.IWord>;\r\n      var arr = mp[word.rule.matchedString][word.rule.bitindex];\r\n      if( arr.length == 0 )\r\n      {\r\n        arr.push(word);\r\n      }\r\n      if ( !arr.every( (presentword) => {\r\n        return CharSequence.CharSequence.isSameOrPluralOrVeryClose( word.string, presentword.string );\r\n      }))\r\n      {\r\n        arr.push( word );\r\n      }\r\n    }\r\n    // retain only entries with more than one member in the list\r\n    var mpduplicates = {} as {[key : string] :  { [key : number] : Array<IMatch.IWord> } };\r\n    Object.keys( mp ).forEach( (key) => {\r\n      var entry = mp[key];\r\n      Object.keys( entry ).forEach( (keybitindex) => {\r\n        if ( entry[keybitindex].length > 1)\r\n        {\r\n          if (!mpduplicates[key])\r\n            mpduplicates[key] = {} as { [key : number] : Array<IMatch.IWord> };\r\n          mpduplicates[key][keybitindex] = entry[keybitindex];\r\n        }\r\n      });\r\n    });\r\n    return Object.keys( mpduplicates ).every( (key) =>  {\r\n      return Object.keys( mpduplicates[ key ] ).every( ( bi ) => {\r\n        var lst = mpduplicates[key][bi];\r\n        var idxmap = {} as { [akey : number] : Array<IMatch.IWord> };\r\n        /* ok, do some work ..  */\r\n        /* for every duplicate we collect an index  idx -> word */\r\n        for( var alst of lst )\r\n        {\r\n          var idx = sentence.indexOf( alst );\r\n          if ( idx < 0 )\r\n            throw new Error(\"word must be found in sentence \");\r\n          idxmap[ idx ] = alst;\r\n        }\r\n        /* then we run through all the sentences identifying *identical source words pairs,\r\n           if we find a  a) distinct sentence with\r\n                      b) same categories F16/F16\r\n                  and c) *higher matches* for both , then we discard *this* sentence\r\n                  */\r\n        return sentences.every( (othersentence) => {\r\n          if( othersentence === sentence )\r\n            return true;\r\n          if ( isSameCategoryAndHigherMatch( othersentence, idxmap) )\r\n          {\r\n            debuglog(\" removing sentence with due to higher match \" +  Sentence.simplifyStringsWithBitIndex(sentence)\r\n            + \" as \" + Sentence.simplifyStringsWithBitIndex( othersentence ) + \" appears better \");\r\n            return false;\r\n          }\r\n          return true;\r\n        });\r\n      })\r\n    });\r\n  });\r\n  debuglog(\" here res \" + !res + \" \" +  Sentence.simplifyStringsWithBitIndex(sentence) );\r\n  return !res;\r\n}\r\n\r\n\r\n/*\r\n * Return true if the identical source word is interpreted\r\n * (within the same domain and the same wordtype)\r\n * as a differnent  (e.g. element numb is one interpreted as 'CAT' element name, once as CAT 'element number' in\r\n * same domain IUPAC elements)\r\n *\r\n * - exact match\r\n * - stemming by removing/appending traling s\r\n * - closeness\r\n *\r\n * @param sentence\r\n */\r\nexport function isDistinctInterpretationForSameOLD(sentence : IMatch.ISentence) : boolean {\r\n  var mp = {} as {[key : string] : IMatch.IWord};\r\n  var res = sentence.every((word, index) => {\r\n    var seen = mp[word.string];\r\n    if(!seen)\r\n    { // exact match\r\n      /*if( word.string.length > 3 && word.string.charAt(word.string.length - 1).toLowerCase() == 's')\r\n      {\r\n\r\n      }\r\n      */\r\n    }\r\n    if(!seen) {\r\n      mp[word.string] = word;\r\n      return true;\r\n    }\r\n    if(!seen.rule || !word.rule) {\r\n      return true;\r\n    }\r\n    if(seen.rule.bitindex === word.rule.bitindex\r\n      && seen.rule.matchedString !== word.rule.matchedString ){\r\n      //  console.log(\"skipping this\" + JSON.stringify(sentence,undefined,2));\r\n        return false;\r\n    }\r\n    return true;\r\n  });\r\n  return res;\r\n}\r\n\r\nexport function filterNonSameInterpretations(aSentences :  IMatch.IProcessedSentences ) : IMatch.IProcessedSentences {\r\n  var discardIndex = [] as Array<number>;\r\n  var res = (Object as any).assign( {}, aSentences );\r\n  res.sentences = aSentences.sentences.filter((sentence,index) => {\r\n    if(!isDistinctInterpretationForSame(sentence)) {\r\n      discardIndex.push(index);\r\n      return false;\r\n    }\r\n    return true;\r\n  });\r\n  if(discardIndex.length) {\r\n    res.errors = aSentences.errors.filter( (error,index) => {\r\n      if(discardIndex.indexOf(index) >= 0) {\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n  }\r\n  return res;\r\n}\r\n\r\nfunction isNullOrEmptyDictionary(obj) {\r\n  return (obj === undefined) || (Object.keys(obj).length === 0);\r\n}\r\n\r\n\r\nexport function filterBadOperatorArgs(aSentences :  IMatch.IProcessedSentences, operators : IFModel.IOperators ) : IMatch.IProcessedSentences {\r\n  if ( isNullOrEmptyDictionary(operators) )\r\n    return aSentences;\r\n  var discardIndex = [] as Array<number>;\r\n  var res = (Object as any).assign( {}, aSentences );\r\n  res.sentences = aSentences.sentences.filter((sentence,index) => {\r\n    if(isBadOperatorArgs(sentence, operators)) {\r\n      discardIndex.push(index);\r\n      return false;\r\n    }\r\n    return true;\r\n  });\r\n  if(discardIndex.length) {\r\n    res.errors = aSentences.errors.filter( (error,index) => {\r\n      if(discardIndex.indexOf(index) >= 0) {\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n  }\r\n  return res;\r\n}\r\n\r\n\r\nexport function filterReverseNonSameInterpretations(aSentences :  IMatch.IProcessedSentences ) : IMatch.IProcessedSentences {\r\n  var discardIndex = [] as Array<number>;\r\n  var res = (Object as any).assign( {}, aSentences );\r\n  res.sentences = aSentences.sentences.filter((sentence,index) => {\r\n    if(isNonOptimalDistinctSourceForSame(sentence, aSentences.sentences)) {\r\n      discardIndex.push(index);\r\n      return false;\r\n    }\r\n    return true;\r\n  });\r\n  if(discardIndex.length) {\r\n    res.errors = aSentences.errors.filter( (error,index) => {\r\n      if(discardIndex.indexOf(index) >= 0) {\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n  }\r\n  return res;\r\n}\r\n\r\nexport function processString2(query: string, rules: IFModel.SplitRules,\r\n words: { [key: string]: Array<IMatch.ICategorizedString> },\r\n operators : { [key:string] : IOperator }\r\n):  IMatch.IProcessedSentences {\r\n  words = words || {};\r\n  var tokenStruct = tokenizeString(query, rules, words);\r\n  debuglog(()=> `tokenized:\\n` + tokenStruct.categorizedWords.map( s => Sentence.simplifyStringsWithBitIndex(s).join(\"\\n\") ).join(\"\\n\"));\r\n  evaluateRangeRulesToPosition(tokenStruct.tokens, tokenStruct.fusable,\r\n    tokenStruct.categorizedWords);\r\n  debuglogV(()=>\"After matched \" + JSON.stringify(tokenStruct.categorizedWords));\r\n  var aSentences = expandTokenMatchesToSentences2(tokenStruct.tokens, tokenStruct.categorizedWords);\r\n  debuglog(() => \"after expand \" + aSentences.sentences.map(function (oSentence) {\r\n    return Sentence.rankingProduct(oSentence) + \":\\n\" + Sentence.dumpNiceBitIndexed(oSentence); //JSON.stringify(oSentence);\r\n    }).join(\"\\n\"));\r\n  aSentences = filterBadOperatorArgs(aSentences, operators)\r\n  aSentences = filterNonSameInterpretations(aSentences);\r\n\r\n  aSentences = filterReverseNonSameInterpretations(aSentences);\r\n\r\n  aSentences.sentences = WordMatch.reinForce(aSentences.sentences);\r\n  debuglogV(()=> \"after reinforce\\n\" + aSentences.sentences.map(function (oSentence) {\r\n      return Sentence.rankingProduct(oSentence) + \":\\n\" + JSON.stringify(oSentence);\r\n    }).join(\"\\n\"));\r\n  debuglog(() => \"after reinforce\" + aSentences.sentences.map(function (oSentence) {\r\n    return Sentence.rankingProduct(oSentence) + \":\\n\" + Sentence.dumpNiceBitIndexed(oSentence); //JSON.stringify(oSentence);\r\n    }).join(\"\\n\"));\r\n  return aSentences;\r\n}\r\n\r\n\r\n"],"sourceRoot":"src/"}