{"version":3,"sources":["/projects/nodejs/botbuilder/mgnlq_parser1/src//projects/nodejs/botbuilder/mgnlq_parser1/src/../src/match/sentence.ts"],"names":[],"mappings":"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","file":"sentence.js","sourcesContent":["/**\r\n * @file sentence\r\n * @module jfseb.fdevstart.sentence\r\n * @copyright (c) Gerd Forstmann\r\n *\r\n * Match a tool record on a sentence,\r\n *\r\n * This will unify matching required and optional category words\r\n * with the requirements of the tool.\r\n *\r\n */\r\n\r\n// <reference path=\"../../lib/node-4.d.ts\" />\r\n\r\nimport * as debug from 'debug';\r\n\r\n// import * as utils from '../utils/utils';\r\n\r\nimport * as IMatch from './iferbase';\r\n\r\nconst debuglog = debug('sentence')\r\n\r\nexport function findWordByCategory(oSentence, sCategory : string) : { word : IMatch.IWord, index : number} {\r\n  \tvar res = {} as { word : IMatch.IWord, index : number};\r\n    oSentence.every(function(oWord, iIndex) {\r\n      if(oWord.category === sCategory) {\r\n        res = { word: oWord,\r\n                index : iIndex };\r\n        return false;\r\n      }\r\n      return true;\r\n    })\r\n    return res;\r\n}\r\n\r\nexport function getDistinctCategoriesInSentence(oSentence : IMatch.ISentence) : string[] {\r\n  var res = [];\r\n  var resm = {};\r\n  oSentence.forEach(function(oWord) {\r\n    if(oWord.category === \"category\") {\r\n      if(!resm[oWord.matchedString]) {\r\n        res.push(oWord.matchedString);\r\n        resm[oWord.matchedString] = 1;\r\n      }\r\n    }\r\n  });\r\n  return res;\r\n}\r\n\r\nexport function rankingGeometricMean(oSentence : IMatch.ISentence) : number {\r\n  const length = oSentence.length;\r\n  if(length === 0) {\r\n    return 1.0;\r\n  }\r\n  var prod =  oSentence.reduce(function(prev, oWord) {\r\n    return prev * (oWord._ranking || 1.0);\r\n  },1.0);\r\n  // TODO: find somethign faster ;-)\r\n  return Math.pow(prod, 1/length);\r\n}\r\n\r\nexport function rankingProduct(oSentence: IMatch.ISentence) : number {\r\n  return rankingGeometricMean(oSentence);\r\n}\r\n\r\nexport function cmpRankingProduct(a : IMatch.ISentence, b : IMatch.ISentence) {\r\n  return - (rankingProduct(a) - rankingProduct(b));\r\n}\r\n\r\nexport function cutoffSentenceAtRatio(sentences : IMatch.ISentence[]) {\r\n  if(sentences.length === 0){\r\n    return sentences;\r\n  }\r\n  var bestRank = rankingProduct(sentences[0]);\r\n  for(var i = 1; (i < Math.min(sentences.length, 300)) && ((rankingProduct(sentences[i])/ bestRank) > 0.8); ++ i) {\r\n    // empty\r\n  }\r\n  debuglog(\"reduce sentences by \" + i + \"/\" + sentences.length);\r\n  return sentences.slice(0,i);\r\n}\r\n\r\n/*\r\nexport function simplifySentence(res : IMatch.ICategorizedStringRanged[][]) : string[][] {\r\n  return res.map(function (r) {\r\n    return r.map(word => { return word.string + '=>' + word.matchedString + '/' + word.category + (word.span ? '/' + word.span : '') })\r\n  });\r\n}\r\n*/\r\n\r\nexport function dumpNice(sentence : IMatch.ISentence, fn?: any) : string {\r\n  var result = [];\r\n    sentence.forEach(function(oWord, index) {\r\n      var sWord = `[${index}] : ${(oWord._ranking || 0).toFixed(3)} ${oWord.category} \"${oWord.string}\" => \"${oWord.matchedString}\"`\r\n      result.push(sWord + \"\\n\");\r\n    })\r\n    result.push(\".\\n\");\r\n    return result.join(\"\");\r\n}\r\n\r\nexport function dumpNiceRuled(sentence : IMatch.ISentence, fn?: any) : string {\r\n  var result = [];\r\n    sentence.forEach(function(oWord, index) {\r\n      var sWord = `[${index}] : ${(oWord._ranking || 0).toFixed(3)} ${oWord.category} \"${oWord.string}\" => \"${oWord.matchedString}\" `\r\n      result.push(sWord + \"\\n\");\r\n    })\r\n    result.push(\".\\n\");\r\n    return result.join(\"\");\r\n}\r\n\r\n\r\nexport function dumpNiceBitIndexed(sentence : IMatch.ISentence, fn?: any) : string {\r\n  var result = [];\r\n    sentence.forEach(function(word, index) {\r\n      var sWord = `[${index}] : ${(word._ranking || 0).toFixed(3)} \"${word.string}\" => \"${word.matchedString}\" `\r\n      + word.category + ((word as any).span? '/' + (word as any).span : '') + ` ${word.rule.wordType}${word.rule.bitindex}`;\r\n      result.push(sWord + \"\\n\");\r\n    })\r\n    result.push(\".\\n\");\r\n    return result.join(\"\");\r\n}\r\n\r\n\r\nexport function dumpNiceArr(sentences : IMatch.ISentence[], fn? : any) : string {\r\n  if(!sentences) {\r\n    return \"\";\r\n  }\r\n  var res = sentences.reduce(function(prev, oSentence) {\r\n    return prev + dumpNice(oSentence);\r\n  }, \"\")\r\n  return res;\r\n}\r\n\r\nexport function simplifyStringsWithBitIndex(sentence : IMatch.ISentence) {\r\n  if(!sentence) {\r\n    return [];\r\n  }\r\n  return sentence.map(word =>  { return word.string + '=>' +  word.matchedString + '/' + word.category + ((word as any).span? '/' + (word as any).span : '') + ` ${word.rule.wordType}${word.rule.bitindex}`})\r\n}\r\n"],"sourceRoot":"src/"}