{"version":3,"sources":["/projects/nodejs/botbuilder/mgnlq_parser1/src//projects/nodejs/botbuilder/mgnlq_parser1/src/../src/mongoq.ts"],"names":[],"mappings":"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","file":"mongoq.js","sourcesContent":["'use strict'\r\n/**\r\n * @file\r\n * @module jfseb.mgnlq_parser1.mongoq\r\n * @copyright (c) 2016-2109 Gerd Forstmann\r\n *\r\n * database connectivity and querying\r\n */\r\n\r\n\r\nimport { Sentence as Sentence, IFErBase as IFErBase } from './match/er_index';\r\nimport { IFModel as IFModel, Model as Model, MongoMap as MongoMap } from 'mgnlq_model';\r\n\r\nimport * as debug from 'debugf';\r\nimport * as _ from 'lodash';\r\n\r\nconst debuglog = debug('mongoq');\r\n\r\nimport * as chevrotain from 'chevrotain';\r\nimport * as AST from './ast';\r\n\r\nimport { ASTNodeType as NT } from './ast';\r\n\r\nvar createToken = chevrotain.createToken;\r\nvar Lexer = chevrotain.Lexer;\r\nvar Parser = chevrotain.Parser;\r\n\r\n\r\n\r\n\r\n\r\nimport * as mongoose from 'mongoose';\r\n\r\nimport * as process from 'process';\r\n\r\n\r\n\r\nexport function JSONStringify(obj: any): string {\r\n  function customSer(key, value) {\r\n    if (value instanceof RegExp)\r\n      return (value.toString());\r\n    else\r\n      return value;\r\n  }\r\n  return JSON.stringify(obj, customSer, 2);\r\n}\r\n\r\nprocess.on(\r\n\r\n  \"unhandledRejection\",\r\n\r\n  function handleWarning(reason, promise) {\r\n    console.log(\"[PROCESS] Unhandled Promise Rejection\");\r\n    console.log(\"- - - - - - - - - - - - - - - - - - -\");\r\n    console.log(reason);\r\n    console.log('');\r\n\r\n  }\r\n\r\n);\r\n\r\nexport function makeMongoName(s: string): string {\r\n  return s.replace(/[^a-zA-Z0-9]/g, '_');\r\n}\r\n\r\n//var mongodb = process.env.ABOT_MONGODB || \"testmodel\";\r\n\r\n\r\n(<any>mongoose).Promise = global.Promise;\r\n\r\nvar db = mongoose.connection;\r\n\r\nexport class MongoBridge {\r\n  _model: IFModel.IModels;\r\n  constructor(model: IFModel.IModels) {\r\n    this._model = model;\r\n  }\r\n  mongoooseDomainToDomain(mgdomain: string): string {\r\n    var domain = undefined;\r\n    debug('searching for .............## ' + mgdomain);\r\n    this._model.domains.every(d => {\r\n      // console.log(\"here we go \"  + mgdomain + \" \" + makeMongoName(d));\r\n      debug(\"here we go \" + mgdomain + \" \" + makeMongoName(d));\r\n      if (makeMongoName(d) === makeMongoName(mgdomain)) {\r\n        domain = d;\r\n        debug('got one ' + d);\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n\r\n    return domain;\r\n  }\r\n\r\n  /*\r\n    makeSchema(mgdomain : string)  : mongoose.Schema {\r\n      debug('makeSchema for ' + mgdomain);\r\n     // console.log('makeschema ' + mgdomain);\r\n      var domain = this.mongoooseDomainToDomain(mgdomain);\r\n      debuglog(()=> ' domain ' + domain);\r\n      debuglog(()=> ` all domains ` + this._model.domains.join(\"; \"));\r\n      var cats = Model.getCategoriesForDomain(this._model, domain);\r\n      var res = {};\r\n      cats.forEach(cat => {\r\n        res[makeMongoName(cat)] = { type : String};\r\n      })\r\n      return new mongoose.Schema(res);\r\n    }\r\n    */\r\n}\r\n\r\n\r\nexport class ModelHandle {\r\n  _theModel: IFModel.IModels;\r\n  _mgBridge: MongoBridge;\r\n  _mongoose: mongoose.Mongoose;\r\n  constructor(theModel: IFModel.IModels) {\r\n    this._theModel = theModel;\r\n    this._mongoose = this._theModel.mongoHandle && this._theModel.mongoHandle.mongoose;\r\n    this._mgBridge = new MongoBridge(theModel);\r\n  }\r\n  query(domain: string, query: any): Promise<any> {\r\n    var that = this;\r\n    var mgmodelname = Model.getMongooseModelNameForDomain(this._theModel, domain); 4\r\n    debuglog('query ' + domain + ' >>' + mgmodelname + ' ' + JSON.stringify(query, undefined, 2));\r\n    return getDBConnection(this._mongoose).then((mongoose) => {\r\n\r\n      return new Promise(function (resolve, reject) {\r\n        Promise.resolve(1).then(() => {\r\n          debuglog('constructing model for ' + mgmodelname);\r\n          if (that._theModel.mongoHandle.mongoose.modelNames().indexOf(mgmodelname) < 0) {\r\n            throw new Error(` ${domain} / ${mgmodelname} is not a present model `);\r\n          }\r\n          var model = that._theModel.mongoHandle.mongoose.model(mgmodelname);\r\n          //\r\n          // console.log('try1');\r\n          //  that._models[mgdomain] = mongoose.model(mgdomain);\r\n          //  console.log('try2');\r\n          //  that._schemas[mgdomain] = mongoose.model(mgdomain).schema;\r\n          //}\r\n          /*\r\n            if(!that._models[mgdomain]) {\r\n              that._schemas[mgdomain] = that._mgBridge.makeSchema(mgdomain);\r\n              that._mongoose.modelNames();\r\n              that._models[mgdomain] = mongoose.model(mgdomain,that._schemas[mgdomain]);\r\n            }\r\n           */\r\n          //  console.log('running stuff')\r\n          // db.fioriboms.aggregate([ { $match : {}}, { $group: { _id : { a : '$BSPName', b : '$AppKey' } , BSPName : { $first : '$BSPName'} , AppKey : { $first : '$AppKey' }}},{ $project: { _id : 0, BSPName : 1 }}], { cursor : {  batchSize : 0}});\r\n          //var model = that._models[mgdomain];\r\n          //  console.log('here model ' + model);\r\n          //  model.collection.count({}, function(err,number) {\r\n          //  console.log(\"counted \" + number + \" members in collection\");\r\n          //  });\r\n          //   console.log(JSON.stringify(query, undefined,2));\r\n          /*  model.collection.count({}, function(a) {\r\n              debuglog('lets count' + a); });\r\n            */\r\n          debuglog(() => 'here model ' + Object.keys(model));\r\n          var resq = model.aggregate(query).then((res) => {\r\n            //   console.log(\"here the result\" + JSON.stringify(res));\r\n            resolve(res);\r\n            //db.close();\r\n          }).catch((err) => {\r\n            console.error(err);\r\n            db.close();\r\n          });\r\n        });\r\n      });\r\n    })\r\n  }\r\n}\r\n\r\nfunction incHash(hsh, key) {\r\n  hsh[key] = (hsh[key] || 0) + 1;\r\n}\r\n\r\n/*\r\nexport function getDomainForSentence2(theModel: IFModel.IModels, sentence : IFErBase.ISentence) : {\r\n  domain: string,\r\n    collectionName: string,\r\n    modelName: string\r\n  }\r\n{\r\n  // this is sloppy and bad\r\n  var res = {};\r\n  var o = 0xFFFFFFF;\r\n  sentence.forEach(w => {\r\n    if (w.rule.wordType === IFModel.WORDTYPE.CATEGORY) {\r\n      o = o & w.rule.bitSentenceAnd;\r\n    }\r\n    if (w.rule.wordType === IFModel.WORDTYPE.FACT) {\r\n      o = o & w.rule.bitSentenceAnd;\r\n    }\r\n  });\r\n  var domains = Model.getDomainsForBitField(theModel, o);\r\n  if (domains.length !== 1) {\r\n    throw new Error('more than one domain: \"' + domains.join('\", \"') + '\"');\r\n  }\r\n  if (!domains[0]) {\r\n    console.log('query without a domain : ' + Sentence.dumpNiceArr([sentence]));\r\n  }\r\n  return {\r\n    domain: domains[0],\r\n    collectionName: Model.getMongoCollectionNameForDomain(theModel, domains[0]),\r\n    modelName: Model.getModelNameForDomain(theModel.mongoHandle, domains[0])\r\n  }\r\n};\r\n\r\n*/\r\n\r\nexport function getDomainForSentenceSafe(theModel: IFModel.IModels, sentence: IFErBase.ISentence) : string {\r\n  try {\r\n    return getDomainInfoForSentence(theModel,sentence).domain;\r\n  } catch(e) {\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * given a Sentence, obtain the domain for it\r\n * @param theModel\r\n * @param sentence\r\n */\r\nexport function getDomainInfoForSentence(theModel: IFModel.IModels, sentence: IFErBase.ISentence): {\r\n  domain: string,\r\n  collectionName: string,\r\n  modelName: string\r\n} {\r\n  // this is sloppy and bad\r\n  var res = {};\r\n  var o = 0xFFFFFFF;\r\n  sentence.forEach(w => {\r\n    if (w.rule.wordType === IFModel.WORDTYPE.CATEGORY) {\r\n      o = o & w.rule.bitSentenceAnd;\r\n      Model.getDomainsForCategory(theModel, w.matchedString).forEach(d => {\r\n        incHash(res, d);\r\n      });\r\n    }\r\n    if (w.rule.wordType === IFModel.WORDTYPE.FACT) {\r\n      o = o & w.rule.bitSentenceAnd;\r\n      //   console.log(`${w.rule.bitindex} ${w.bitindex} ${w.rule.bitSentenceAnd} ${o} `);\r\n      Model.getDomainsForCategory(theModel, w.category).forEach(d => {\r\n        incHash(res, d);\r\n      });\r\n    }\r\n  });\r\n  var domains = Model.getDomainsForBitField(theModel, o);\r\n  if (domains.length !== 1) {\r\n    throw new Error('more than one domain: \"' + domains.join('\", \"') + '\"');\r\n  }\r\n  if (!domains[0]) {\r\n    console.log('query without a domain : ' + Sentence.dumpNiceArr([sentence]));\r\n  }\r\n  return {\r\n    domain: domains[0],\r\n    collectionName: Model.getMongoCollectionNameForDomain(theModel, domains[0]),\r\n    modelName: Model.getModelNameForDomain(theModel.mongoHandle, domains[0])\r\n  }\r\n};\r\n\r\n//import { IFErBase as IMatch, ErError as ErError } from './match/index';\r\n\r\nimport * as mQ from './ast2query/ast2MQuery';\r\n\r\nexport interface SRes {\r\n  sentence: IFErBase.ISentence,\r\n  records: any[]\r\n};\r\n\r\nexport interface QResult {\r\n  domain: string,\r\n  sentence: IFErBase.ISentence,\r\n  columns: string[],\r\n  results: string[][]\r\n};\r\n\r\nexport interface IResultRecord  { [key: string] : Number | string };\r\n\r\nexport interface IQueryResult {\r\n  domain: string,\r\n  aux : {\r\n    sentence: IFErBase.ISentence,\r\n    tokens : string[],\r\n    astnode? : AST.ASTNode\r\n  }\r\n  errors : any,  // undefined for ok result\r\n  /**\r\n   * Columns relevant for output, in \"query\" / \"sentence\" order\r\n   */\r\n  columns: string[], // columns relevant for output\r\n  auxcolumns?  : string[],  // contains additional columns, usually not present!\r\n  results: IResultRecord[]\r\n};\r\n\r\n\r\n\r\nfunction getDBConnection(mongooseHndl: mongoose.Mongoose): Promise<mongoose.Connection> {\r\n  if (mongooseHndl) {\r\n    debuglog('assuming present handle');\r\n    // we assume we are connected\r\n    return Promise.resolve(mongooseHndl.connection);\r\n  }\r\n  throw Error('how is this gonna work');\r\n}\r\n\r\nimport * as SentenceParser from './sentenceparser';\r\n\r\nexport interface IQuery {\r\n  domain: string,\r\n  columns: string[],\r\n  auxcolumns? : string[],\r\n  reverseMap: IReverseMap,\r\n  query: any\r\n};\r\n\r\nexport interface IPreparedQuery extends SentenceParser.IParsedSentences {\r\n  queries: IQuery[]\r\n};\r\n\r\nexport function makeAggregateFromAst(astnode: AST.ASTNode, sentence: IFModel.IWord[],\r\n  models : IFModel.IModels,\r\n  collectionName : string, fixedCategories) {\r\n  var nodeFieldList = astnode.children[0].children[0];\r\n  var nodeFilter = astnode.children[1];\r\n  var mongoMap = undefined as IFModel.CatMongoMap;\r\n  mongoMap = models.mongoHandle.mongoMaps[collectionName];\r\n  var modelHandleRaw = models.mongoHandle;\r\n  // todo: detect any explicit sorts\r\n  // { sortCartegoryList : [\"cat1\"],\r\n  //  [ {cat1 : 1} ,{ cat2 : -1} ]\r\n  //\r\n  // then iff explicit sort,\r\n  // project out cat+sortCart, the then sort by it, only then project out desiredcat\r\n  //\r\n  //}//\r\n  var explicitSort = mQ.extractExplicitSortFromAst( nodeFilter, sentence, mongoMap, collectionName, modelHandleRaw );\r\n\r\n  var match = mQ.makeMongoMatchFromAst(nodeFilter, sentence,  mongoMap, collectionName, modelHandleRaw);\r\n  // TODO: be better than full unwind, use only relelvant categories!\r\n  var unwind = MongoMap.unwindsForNonterminalArrays(mongoMap);\r\n  var head = [match] as any[];\r\n  if (unwind.length) {\r\n    head = head.concat(unwind);\r\n    head.push(match);\r\n  }\r\n  var categoryList = mQ.getCategoryList(fixedCategories, nodeFieldList, sentence);\r\n  var categoryListPlusExplicitSort = mQ.amendCategoryList(explicitSort, categoryList);\r\n  var proj = mQ.makeMongoProjectionFromAst(categoryList, mongoMap);\r\n  var sort = mQ.makeMongoSortFromAst(categoryList, mongoMap);\r\n  var group = mQ.makeMongoGroupFromAst(categoryList, mongoMap);\r\n  var columnsReverseMap = mQ.makeMongoColumnsFromAst(categoryList, mongoMap);\r\n\r\n  console.log(\" catPlus \" + JSON.stringify(categoryListPlusExplicitSort));\r\n  var projExplicit = mQ.makeMongoProjectionFromAst(categoryListPlusExplicitSort, mongoMap);\r\n  var sortExplicit = mQ.makeMongoExplicitSort(explicitSort, categoryList, mongoMap);\r\n  var groupExplicit = mQ.makeMongoGroupFromAst(categoryListPlusExplicitSort, mongoMap);\r\n  //   console.log(' query: ' + JSON.stringify(r)); // how to get domain?\r\n  // test.equal(domain, 'FioriBOM',' got domain');\r\n  console.log(\" explicitSort\" + JSON.stringify(explicitSort));\r\n  var query = ( explicitSort.length > 0) ?\r\n        head.concat([sortExplicit, groupExplicit, projExplicit, sortExplicit, proj ])\r\n      : head.concat([group, proj, sort]);\r\n  return { query: query, columnsReverseMap: columnsReverseMap };\r\n}\r\n\r\n\r\nexport function containsFixedCategories(theModel: IFModel.IModels, domain: string, fixedCategories: string[]): boolean {\r\n  if (fixedCategories.length === 0) {\r\n    return true;\r\n  }\r\n  var cats = Model.getCategoriesForDomain(theModel, domain);\r\n  return _.intersection(cats, fixedCategories).length === fixedCategories.length;\r\n}\r\n\r\nexport function augmentCategoriesWithURI(fixedCategories : string[], theModel : IFModel.IModels, domain : string) : string[] {\r\n  var uris = Model.getShowURICategoriesForDomain(theModel, domain);\r\n  var ranks = Model.getShowURIRankCategoriesForDomain(theModel, domain);\r\n  return _.union(uris, ranks, fixedCategories);\r\n}\r\n\r\nexport function prepareQueries(query: string, theModel: IFModel.IModels, fixedCategories: string[], options? : IQueryOptions): IPreparedQuery {\r\n  debuglog(`here query: ${query}`);\r\n  var r = SentenceParser.parseSentenceToAsts(query, theModel, {}); // words);\r\n  var res = Object.assign({}, r) as IPreparedQuery;\r\n  debuglog( ()=> ' parsed ' + JSON.stringify(r));\r\n  r.domains = [];\r\n  res.queries = res.asts.map((astnode, index) => {\r\n    var sentence = r.sentences[index];\r\n    debuglog(() => `return  ast [${index}]:` + AST.astToText(astnode));\r\n    if (!astnode) {\r\n      debuglog(() => JSON.stringify(` empty node for ${index} ` + JSON.stringify(r.errors[index], undefined, 2)));\r\n      return undefined;\r\n    }\r\n    var domainPick = getDomainInfoForSentence(theModel, sentence);\r\n    debuglog(() => ' domainPick: ' + JSON.stringify(domainPick, undefined, 2));\r\n    var domainFixedCategories : string[] = [];\r\n    if(options && options.showURI) {\r\n      domainFixedCategories = augmentCategoriesWithURI(fixedCategories, theModel, domainPick.domain);\r\n    } else {\r\n      domainFixedCategories = fixedCategories;\r\n    }\r\n    var mongoMap = theModel.mongoHandle.mongoMaps[domainPick.collectionName];\r\n    if (!containsFixedCategories(theModel, domainPick.domain, domainFixedCategories)) {\r\n      debuglog(() => JSON.stringify(` fixed fields not present in domain ${domainPick.domain} given fields ${domainFixedCategories.join(\";\")} for ${index} `));\r\n      return undefined;\r\n    }\r\n    var res = makeAggregateFromAst(astnode, sentence,theModel, domainPick.collectionName, domainFixedCategories);\r\n    var query = res.query;\r\n    var columnsReverseMap = res.columnsReverseMap;\r\n    /*\r\n        var nodeFieldList = astnode.children[0].children[0];\r\n        var nodeFilter = astnode.children[1];\r\n        var match = mQ.makeMongoMatchFromAst(nodeFilter, sentence, mongoMap);\r\n\r\n    // TODO: be better than full unwind, use only relelvant categories!\r\n          var MongomMap = MongoMap.unwindsForNonterminalArrays(mongoMap);\r\n\r\n        var proj = mQ.makeMongoProjectionFromAst(nodeFieldList, sentence, mongoMap);\r\n        var columnsReverseMap= mQ.makeMongoColumnsFromAst(nodeFieldList, sentence, mongoMap);\r\n        var group = mQ.makeMongoGroupFromAst(nodeFieldList, sentence, mongoMap);\r\n        //   console.log(' query: ' + JSON.stringify(r)); // how to get domain?\r\n       // test.equal(domain, 'FioriBOM',' got domain');\r\n        var query = [ match, group, proj ];\r\n      */\r\n    r.domains[index] = domainPick.domain;\r\n    debuglog(() => ` mongo query for collection ${domainPick.collectionName} : ` + JSONStringify(query));\r\n    debuglog(() => ` columnmap ` + JSON.stringify(columnsReverseMap, undefined, 2));\r\n    return {\r\n      domain: domainPick.domain,\r\n      collectionName: domainPick.collectionName,\r\n      columns: columnsReverseMap.columns,\r\n      auxcolumns : [], // ? // TODO  allcolumns\r\n      reverseMap: columnsReverseMap.reverseMap,\r\n      query: query\r\n    };\r\n  });\r\n  return res;\r\n}\r\n\r\nexport type IProcessedMongoAnswers = IQueryResult[];\r\n//extends IMatch.IProcessedSentences {\r\n//  queryresults: QResult[]\r\n//}\r\n\r\n/* result format redesign */\r\n/* 1) ability to transport the AST */\r\n/* 2) ability to transport auxiliary information  ( e.g. _url )  */\r\n/* 3) result objects  map [{  prop : value }] as this is more natural , not string[][] */\r\n/* single array of \"alternating options\" */\r\n\r\n\r\n\r\nexport function queryWithAuxCategories(query: string, theModel: IFModel.IModels, auxiliary_categories : string[]): Promise<IProcessedMongoAnswers> {\r\n  var handle = new ModelHandle(theModel);\r\n  return queryInternal(query, theModel, handle, auxiliary_categories);\r\n}\r\n\r\n\r\nexport function queryWithURI(query: string, theModel: IFModel.IModels, auxiliary_categories : string[]): Promise<IProcessedMongoAnswers> {\r\n  var handle = new ModelHandle(theModel);\r\n  return queryInternal(query, theModel, handle, [], { showURI : true });\r\n}\r\n\r\nexport function query(query: string, theModel: IFModel.IModels): Promise<IProcessedMongoAnswers> {\r\n  var handle = new ModelHandle(theModel);\r\n  return queryInternal(query, theModel, handle, []);\r\n}\r\n\r\nexport type IReverseMap = { [key: string]: string };\r\n\r\nexport function remapRecord(rec, columns: string[], reverseMap: IReverseMap): IResultRecord {\r\n  var r = {};\r\n  Object.keys(rec).forEach(key => {\r\n    var targetKey = reverseMap[key] || key;\r\n    r[targetKey] = rec[key];\r\n  });\r\n  return r; // columns.map(c => r[c]);\r\n};\r\n\r\n\r\nexport function projectResultToArray( res: IQueryResult ) : (string| Number)[][] {\r\n  debuglog(' full :' + JSON.stringify(res));\r\n  return res.results.map( rec =>\r\n    res.columns.map(c => rec[c])\r\n  );\r\n}\r\n\r\nexport function remapResult(res, columns: string[], reverseMap: IReverseMap): IResultRecord[] {\r\n  return res.map(record => remapRecord(record, columns, reverseMap) );\r\n}\r\n\r\nexport interface IQueryOptions {\r\n  showURI : boolean\r\n};\r\n\r\nexport function queryInternal(querystring: string, theModel: IFModel.IModels, handle: ModelHandle, fixedFields: string[], options? :IQueryOptions ):\r\n  Promise<IProcessedMongoAnswers> {\r\n  fixedFields = fixedFields || [];\r\n  var r = prepareQueries(querystring, theModel, fixedFields, options);\r\n  debuglog(()=> 'here prepared queries: ' + JSON.stringify(r));\r\n  if(r.queries.length === 0) {\r\n    return Promise.resolve<IProcessedMongoAnswers>(\r\n      [{\r\n        domain : undefined,\r\n        aux : { sentence : undefined,\r\n          tokens : r.tokens },\r\n        errors : r.errors,\r\n        columns : [],\r\n        auxcolumns : [],\r\n        results : []\r\n      }]\r\n    );\r\n  };\r\n  var aPromises = r.queries.map((query, index) => {\r\n    debuglog(() => `query ${index} prepared for domain ` + (query && query.domain));\r\n    debuglog(() => `query ${index} prepared for domain ` + (query && query.domain && getDomainForSentenceSafe(theModel,r.sentences[index])));\r\n\r\n    if (query === undefined) {\r\n      return {\r\n        // TODO may not always be possible\r\n        domain : getDomainForSentenceSafe(theModel,r.sentences[index]),\r\n        aux : {\r\n          sentence: r.sentences[index],\r\n          tokens : r.tokens\r\n        },\r\n        errors : r.errors[index],\r\n        columns: [],\r\n        auxcolumns: [],\r\n        results: []\r\n      } //as IQueryResult\r\n    }\r\n    return handle.query(query.domain, query.query).then(res => {\r\n      //console.log('db returned' + res);\r\n      var resClean = remapResult(res, r.queries[index].columns, query.reverseMap);\r\n      return {\r\n        domain : query.domain,\r\n        aux : {\r\n          sentence: r.sentences[index],\r\n          tokens : r.tokens\r\n        },\r\n        errors : r.errors[index],\r\n        columns: r.queries[index].columns,\r\n        auxcolumns : r.queries[index].auxcolumns,\r\n        results: resClean\r\n      } as IQueryResult\r\n    })\r\n  }\r\n  );\r\n  var u = Promise.all<IQueryResult>(aPromises);\r\n  var k = u.then<IProcessedMongoAnswers>(aRes => {\r\n    debuglog(\"***here results of all queries \" + JSON.stringify(aRes, undefined, 2));\r\n    var queryresults = aRes; // mergeResults(aRes);\r\n    return queryresults;\r\n    /*\r\n    var res2 = {\r\n      domain\r\n\r\n    } as IProcessedMongoAnswers;\r\n\r\n    /*\r\n    var res2 = {\r\n      queryresults: queryresults,\r\n      errors: r.errors, // [ErError.makeError_EMPTY_INPUT()] ,\r\n      tokens: r.tokens,\r\n    } as IProcessedMongoAnswers;\r\n    */\r\n   // return res2;\r\n\r\n  }\r\n  );\r\n  return k;\r\n}\r\n\r\n\r\n/*\r\n\r\n\r\n          export interface IWhatIsTupelAnswer {\r\n              sentence: ISentence;\r\n              record: IRecord;\r\n              categories: string[];\r\n              result: string[];\r\n              _ranking: number;\r\n          }\r\n\r\n\r\n\r\n\r\n\r\n      });\r\n    }\r\n  //  logPerf('listAllWithContext');\r\n  //  perflog(\"totalListAllWithContext\");\r\n    var aSentencesReinforced = analyzeContextString(contextQueryString, aRules);\r\n  //  perflog(\"LATWC matching records (s=\" + aSentencesReinforced.sentences.length + \")...\");\r\n    var matchedAnswers = WhatIs.matchRecordsQuickMultipleCategories(aSentencesReinforced, categories, records, domainCategoryFilter); //aTool: Array<IMatch.ITool>): any /* objectstream * / {\r\n    if(debuglog.enabled){\r\n      debuglog(\" matched Answers\" + JSON.stringify(matchedAnswers, undefined, 2));\r\n    }\r\n  //  perflog(\"filtering topRanked (a=\" + matchedAnswers.tupelanswers.length + \")...\");\r\n //   var matchedFiltered = WhatIs.filterOnlyTopRankedTupel(matchedAnswers.tupelanswers);\r\n //   if (debuglog.enabled) {\r\n //     debuglog(\"LATWC matched top-ranked Answers\" + JSON.stringify(matchedFiltered, undefined, 2));\r\n //   }\r\n  }\r\n}\r\n*/"],"sourceRoot":"ABC"}