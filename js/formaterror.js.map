{"version":3,"sources":["/projects/nodejs/botbuilder/abot_stringdist/src/../src/formaterror.ts"],"names":[],"mappings":"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","file":"formaterror.js","sourcesContent":["/**\r\n * @file formaterror.ts\r\n *\r\n * Formats (some) parser errors into a human understandable text\r\n *\r\n * (c) gerd forstmann 2017\r\n */\r\n\r\nimport * as debug from 'debugf';\r\nconst debuglog = debug('formaterror');\r\n\r\nimport { IFModel as IFModel } from 'mgnlq_model';\r\nimport { ErBase as ErBase, Sentence as Sentence, IFErBase as IFErBase } from 'mgnlq_er';\r\n\r\n//t[{\"name\":\"NoViableAltException\",\"message\":\"Expecting: one of these possible Token sequences:\\n  1. [AFact]\\n  2. [AnANY]\\nbut found: ''\",\"token\":{\"image\":\"\",\"startOffset\":null,\"endOffset\":null,\"startLine\":null,\"endLine\":null,\"startColumn\":null,\"endColumn\":null,\"tokenType\":1},\"resyncedTokens\":[],\"context\":{\"ruleStack\":[\"catListOpMore\",\"factOrAny\"],\r\n\r\nexport function getTokenText(token : any, sentence : IFErBase.ISentence) {\r\n    return getSentenceToken(token,sentence).string;\r\n}\r\n\r\nexport function getSentenceToken(token : any, sentence : IFErBase.ISentence) : IFErBase.IWord {\r\n    if(Number.isNaN(token.startOffset) || token.startOffset >= sentence.length) {\r\n        throw Error('access outside of index' + token.startOffset + \" / \" + sentence.length);\r\n    }\r\n    return sentence[token.startOffset];\r\n}\r\n\r\n\r\nexport function getTokenQualifier(token : any, sentence : IFErBase.ISentence) {\r\n    return getQualifierFromWordType(getSentenceToken(token,sentence).rule.wordType );\r\n}\r\n\r\nexport function getQualifierFromWordType(wordType : string) : string {\r\n    switch(wordType) {\r\n        case IFModel.WORDTYPE.FACT :\r\n            return \"the fact\";\r\n        case IFModel.WORDTYPE.CATEGORY:\r\n            return \"the category\"\r\n        case IFModel.WORDTYPE.DOMAIN:\r\n            return \"the domain\"\r\n        case IFModel.WORDTYPE.OPERATOR:\r\n            return \"the operator\"\r\n    }\r\n    return \"\";\r\n}\r\n\r\n\r\n\r\nexport interface IParseError {\r\n    text : string,\r\n    error : any\r\n}\r\n\r\nexport function getExpecting(message : string) : string {\r\n    //    return \"A\"\r\n    //Error: NoViableAltException: Expecting: one of these possible Token sequences:\r\n    //  1. [AFact]\r\n    //  2. [AnANY]\r\n    // todo extract and format alternatives...\r\n    var arr = extractExpectArr(message).map(r => mapTokenStringToHumanString(r)).filter(r => !!r);\r\n    var res = arr.join(\" or a \");\r\n    if (res.length) {\r\n        return \"a \" + res;\r\n    }\r\n    return undefined; // 'a fact or a string fragment';\r\n}\r\n\r\nexport function mapTokenStringToHumanString(tokenstring : string ) : string {\r\n    switch(tokenstring) {\r\n        case \"AFact\":\r\n            return \"fact\";\r\n        case \"AnANY\":\r\n            return \"string fragment\"\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function extractExpectArr(message : string) : string[] {\r\n    debuglog(message);\r\n    var r = /\\d+\\. \\[([^\\]]+)\\]/g;\r\n    var results = [];\r\n    var match = r.exec(message);\r\n    while (match != null) {\r\n        //console.log(' here ' + JSON.stringify(match));\r\n        //console.log(' here  0 ' + match[0]);\r\n        //console.log(' here  1 ' + match[1]);\r\n        //console.log(' here  2 ' + match[2]);\r\n        results.push(match[1]);\r\n        match = r.exec(message);\r\n    }\r\n    return results;\r\n}\r\n\r\nexport function formatError(error : any, sentence : IFErBase.ISentence) : IParseError {\r\n    debuglog(() => 'error : ' + JSON.stringify(error));\r\n    if ((error.name === \"NotAllInputParsedException\") && error.token && (error.token.startOffset !== null) ) {\r\n        var tok = getTokenText(error.token, sentence);\r\n        var qualifier = getTokenQualifier(error.token,sentence);\r\n        return { text :\r\n                `I do not understand ${qualifier} \"${tok}\" at this position in the sentence.`,\r\n                error : error };\r\n    }\r\n    if ((error.name === \"NoViableAltException\") && error.token && (Number.isNaN(error.token.startOffset)) ) {\r\n        var expect = getExpecting(error.message);\r\n        return { text :\r\n                `Sentence terminated unexpectedly, i expected ${expect}.`,\r\n                error : error };\r\n    }\r\n    //(error.name === \"NoViableAltException\")\r\n    return { error : error,\r\n        text : JSON.stringify(error)\r\n    }\r\n}"],"sourceRoot":"ABC"}