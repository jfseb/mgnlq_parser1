{"version":3,"sources":["/projects/nodejs/botbuilder/mgnlq_parser1/src//projects/nodejs/botbuilder/mgnlq_parser1/src/../src/formaterror.ts"],"names":[],"mappings":"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","file":"formaterror.js","sourcesContent":["/**\r\n * @file formaterror.ts\r\n *\r\n * Formats (some) parser errors into a human understandable text\r\n *\r\n * (c) gerd forstmann 2017-2019\r\n */\r\n\r\nimport * as debug from 'debugf';\r\nconst debuglog = debug('formaterror');\r\n\r\nimport { IFModel as IFModel } from 'mgnlq_model';\r\nimport { Sentence as Sentence, IFErBase as IFErBase } from './match/er_index';\r\n\r\nexport function getTokenText(token : any, sentence : IFErBase.ISentence) {\r\n    return getSentenceToken(token,sentence).string;\r\n}\r\n\r\nexport function getSentenceToken(token : any, sentence : IFErBase.ISentence) : IFErBase.IWord {\r\n    if(Number.isNaN(token.startOffset) || token.startOffset >= sentence.length) {\r\n        throw Error('access outside of index' + token.startOffset + \" / \" + sentence.length);\r\n    }\r\n    return sentence[token.startOffset];\r\n}\r\n\r\n\r\nexport function getTokenQualifier(token : any, sentence : IFErBase.ISentence) {\r\n    return getQualifierFromWordType(getSentenceToken(token,sentence).rule.wordType );\r\n}\r\n\r\nexport function getQualifierFromWordType(wordType : string) : string {\r\n    switch(wordType) {\r\n        case IFModel.WORDTYPE.FACT :\r\n            return \"the fact\";\r\n        case IFModel.WORDTYPE.CATEGORY:\r\n            return \"the category\"\r\n        case IFModel.WORDTYPE.DOMAIN:\r\n            return \"the domain\"\r\n        case IFModel.WORDTYPE.OPERATOR:\r\n            return \"the operator\"\r\n    }\r\n    return \"\";\r\n}\r\n\r\n\r\n\r\nexport interface IParseError {\r\n    text : string,\r\n    error : any\r\n}\r\n\r\nexport function getExpecting(message : string) : string {\r\n    //    return \"A\"\r\n    //Error: NoViableAltException: Expecting: one of these possible Token sequences:\r\n    //  1. [FACT]\r\n    //  2. [AnANY]\r\n    // todo extract and format alternatives...\r\n    var arr = extractExpectArr(message).map(r => mapTokenStringToHumanString(r)).filter(r => !!r);\r\n    var res = arr.join(\" or a \");\r\n    if (res.length) {\r\n        return \"a \" + res;\r\n    }\r\n    return undefined; // 'a fact or a string fragment';\r\n}\r\n\r\nexport function mapTokenStringToHumanString(tokenstring : string ) : string {\r\n    switch(tokenstring) {\r\n        case \"FACT\":\r\n            return \"fact\";\r\n        case \"AnANY\":\r\n            return \"string fragment\";\r\n        case 'TInteger':\r\n        case 'Integer':\r\n        case '12':\r\n        case 'NUMBER':\r\n            return 'number';\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function extractExpectArr(message : string) : string[] {\r\n    debuglog(message);\r\n    var r = /\\d+\\. \\[([^\\]]+)\\]/g;\r\n    var results = [];\r\n    var match = r.exec(message);\r\n    while (match != null) {\r\n        //console.log(' here ' + JSON.stringify(match));\r\n        //console.log(' here  0 ' + match[0]);\r\n        //console.log(' here  1 ' + match[1]);\r\n        //console.log(' here  2 ' + match[2]);\r\n        results.push(match[1]);\r\n        match = r.exec(message);\r\n    }\r\n    return results;\r\n}\r\n\r\nexport function formatError(error : any, sentence : IFErBase.ISentence) : IParseError {\r\n    debuglog(() => 'error : ' + JSON.stringify(error));\r\n    if ((error.name === \"NotAllInputParsedException\") && error.token && (error.token.startOffset !== null) ) {\r\n        var tok = getTokenText(error.token, sentence);\r\n        var qualifier = getTokenQualifier(error.token,sentence);\r\n        return { text :\r\n                `I do not understand ${qualifier} \"${tok}\" at this position in the sentence.`,\r\n                error : error };\r\n    }\r\n    if ((error.name === \"NoViableAltException\") && error.token && (Number.isNaN(error.token.startOffset)) ) {\r\n        var expect = getExpecting(error.message);\r\n        return { text :\r\n                `Sentence terminated unexpectedly, i expected ${expect}.`,\r\n                error : error };\r\n    }\r\n    //(error.name === \"NoViableAltException\")\r\n    return { error : error,\r\n        text : JSON.stringify(error)\r\n    }\r\n}"],"sourceRoot":"src/"}